{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = void 0;\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nfunction _pack(type, value, isArray) {\n  switch (type) {\n    case \"address\":\n      if (isArray) {\n        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));\n      }\n      return (0, index_js_3.getBytes)((0, index_js_1.getAddress)(value));\n    case \"string\":\n      return (0, index_js_3.toUtf8Bytes)(value);\n    case \"bytes\":\n      return (0, index_js_3.getBytes)(value);\n    case \"bool\":\n      value = !!value ? \"0x01\" : \"0x00\";\n      if (isArray) {\n        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));\n      }\n      return (0, index_js_3.getBytes)(value);\n  }\n  let match = type.match(regexNumber);\n  if (match) {\n    let signed = match[1] === \"int\";\n    let size = parseInt(match[2] || \"256\");\n    (0, index_js_3.assertArgument)((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\n    if (isArray) {\n      size = 256;\n    }\n    if (signed) {\n      value = (0, index_js_3.toTwos)(value, size);\n    }\n    return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)((0, index_js_3.toBeArray)(value), size / 8));\n  }\n  match = type.match(regexBytes);\n  if (match) {\n    const size = parseInt(match[1]);\n    (0, index_js_3.assertArgument)(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\n    (0, index_js_3.assertArgument)((0, index_js_3.dataLength)(value) === size, `invalid value for ${type}`, \"value\", value);\n    if (isArray) {\n      return (0, index_js_3.getBytes)((0, index_js_3.zeroPadBytes)(value, 32));\n    }\n    return value;\n  }\n  match = type.match(regexArray);\n  if (match && Array.isArray(value)) {\n    const baseType = match[1];\n    const count = parseInt(match[2] || String(value.length));\n    (0, index_js_3.assertArgument)(count === value.length, `invalid array length for ${type}`, \"value\", value);\n    const result = [];\n    value.forEach(function (value) {\n      result.push(_pack(baseType, value, true));\n    });\n    return (0, index_js_3.getBytes)((0, index_js_3.concat)(result));\n  }\n  (0, index_js_3.assertArgument)(false, \"invalid type\", \"type\", type);\n}\n// @TODO: Array Enum\n/**\n *   Computes the [[link-solc-packed]] representation of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPacked(types, values) {\n  (0, index_js_3.assertArgument)(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n  const tight = [];\n  types.forEach(function (type, index) {\n    tight.push(_pack(type, values[index]));\n  });\n  return (0, index_js_3.hexlify)((0, index_js_3.concat)(tight));\n}\nexports.solidityPacked = solidityPacked;\n/**\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPackedKeccak256(types, values) {\n  return (0, index_js_2.keccak256)(solidityPacked(types, values));\n}\nexports.solidityPackedKeccak256 = solidityPackedKeccak256;\n/**\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPackedSha256(types, values) {\n  return (0, index_js_2.sha256)(solidityPacked(types, values));\n}\nexports.solidityPackedSha256 = solidityPackedSha256;","map":{"version":3,"sources":["../../src.ts/hash/solidity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = void 0;\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nfunction _pack(type, value, isArray) {\n    switch (type) {\n        case \"address\":\n            if (isArray) {\n                return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));\n            }\n            return (0, index_js_3.getBytes)((0, index_js_1.getAddress)(value));\n        case \"string\":\n            return (0, index_js_3.toUtf8Bytes)(value);\n        case \"bytes\":\n            return (0, index_js_3.getBytes)(value);\n        case \"bool\":\n            value = (!!value ? \"0x01\" : \"0x00\");\n            if (isArray) {\n                return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));\n            }\n            return (0, index_js_3.getBytes)(value);\n    }\n    let match = type.match(regexNumber);\n    if (match) {\n        let signed = (match[1] === \"int\");\n        let size = parseInt(match[2] || \"256\");\n        (0, index_js_3.assertArgument)((!match[2] || match[2] === String(size)) && (size % 8 === 0) && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\n        if (isArray) {\n            size = 256;\n        }\n        if (signed) {\n            value = (0, index_js_3.toTwos)(value, size);\n        }\n        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)((0, index_js_3.toBeArray)(value), size / 8));\n    }\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n        (0, index_js_3.assertArgument)(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\n        (0, index_js_3.assertArgument)((0, index_js_3.dataLength)(value) === size, `invalid value for ${type}`, \"value\", value);\n        if (isArray) {\n            return (0, index_js_3.getBytes)((0, index_js_3.zeroPadBytes)(value, 32));\n        }\n        return value;\n    }\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        (0, index_js_3.assertArgument)(count === value.length, `invalid array length for ${type}`, \"value\", value);\n        const result = [];\n        value.forEach(function (value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return (0, index_js_3.getBytes)((0, index_js_3.concat)(result));\n    }\n    (0, index_js_3.assertArgument)(false, \"invalid type\", \"type\", type);\n}\n// @TODO: Array Enum\n/**\n *   Computes the [[link-solc-packed]] representation of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPacked(types, values) {\n    (0, index_js_3.assertArgument)(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n    const tight = [];\n    types.forEach(function (type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return (0, index_js_3.hexlify)((0, index_js_3.concat)(tight));\n}\nexports.solidityPacked = solidityPacked;\n/**\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPackedKeccak256(types, values) {\n    return (0, index_js_2.keccak256)(solidityPacked(types, values));\n}\nexports.solidityPackedKeccak256 = solidityPackedKeccak256;\n/**\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nfunction solidityPackedSha256(types, values) {\n    return (0, index_js_2.sha256)(solidityPacked(types, values));\n}\nexports.solidityPackedSha256 = solidityPackedSha256;\n//# sourceMappingURL=solidity.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}