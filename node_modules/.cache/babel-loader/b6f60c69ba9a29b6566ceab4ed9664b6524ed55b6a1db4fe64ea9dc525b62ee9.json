{"ast":null,"code":"\"use strict\";\n\nvar _classPrivateMethodInitSpec = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nfunction getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if ((0, index_js_1.isHexString)(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  (0, index_js_1.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\nexports.getPollingSubscriber = getPollingSubscriber;\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _poller = /*#__PURE__*/new WeakMap();\nvar _interval = /*#__PURE__*/new WeakMap();\nvar _blockNumber = /*#__PURE__*/new WeakMap();\nvar _poll = /*#__PURE__*/new WeakSet();\nclass PollingBlockSubscriber {\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n\n  /**\n   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateMethodInitSpec(this, _poll);\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _poller, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _interval, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _blockNumber, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider, provider);\n    _classPrivateFieldSet(this, _poller, null);\n    _classPrivateFieldSet(this, _interval, 4000);\n    _classPrivateFieldSet(this, _blockNumber, -2);\n  }\n  /**\n   *  The polling interval.\n   */\n  get pollingInterval() {\n    return _classPrivateFieldGet(this, _interval);\n  }\n  set pollingInterval(value) {\n    _classPrivateFieldSet(this, _interval, value);\n  }\n  start() {\n    if (_classPrivateFieldGet(this, _poller)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _poller, _classPrivateFieldGet(this, _provider)._setTimeout(_classPrivateMethodGet(this, _poll, _poll2).bind(this), _classPrivateFieldGet(this, _interval)));\n    _classPrivateMethodGet(this, _poll, _poll2).call(this);\n  }\n  stop() {\n    if (!_classPrivateFieldGet(this, _poller)) {\n      return;\n    }\n    _classPrivateFieldGet(this, _provider)._clearTimeout(_classPrivateFieldGet(this, _poller));\n    _classPrivateFieldSet(this, _poller, null);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(this, _blockNumber, -2);\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nasync function _poll2() {\n  try {\n    const blockNumber = await _classPrivateFieldGet(this, _provider).getBlockNumber();\n    // Bootstrap poll to setup our initial block number\n    if (_classPrivateFieldGet(this, _blockNumber) === -2) {\n      _classPrivateFieldSet(this, _blockNumber, blockNumber);\n      return;\n    }\n    // @TODO: Put a cap on the maximum number of events per loop?\n    if (blockNumber !== _classPrivateFieldGet(this, _blockNumber)) {\n      for (let b = _classPrivateFieldGet(this, _blockNumber) + 1; b <= blockNumber; b++) {\n        // We have been stopped\n        if (_classPrivateFieldGet(this, _poller) == null) {\n          return;\n        }\n        await _classPrivateFieldGet(this, _provider).emit(\"block\", b);\n      }\n      _classPrivateFieldSet(this, _blockNumber, blockNumber);\n    }\n  } catch (error) {\n    // @TODO: Minor bump, add an \"error\" event to let subscribers\n    //        know things went awry.\n    //console.log(error);\n  }\n  // We have been stopped\n  if (_classPrivateFieldGet(this, _poller) == null) {\n    return;\n  }\n  _classPrivateFieldSet(this, _poller, _classPrivateFieldGet(this, _provider)._setTimeout(_classPrivateMethodGet(this, _poll, _poll2).bind(this), _classPrivateFieldGet(this, _interval)));\n}\nexports.PollingBlockSubscriber = PollingBlockSubscriber;\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider2 = /*#__PURE__*/new WeakMap();\nvar _poll3 = /*#__PURE__*/new WeakMap();\nvar _running = /*#__PURE__*/new WeakMap();\nclass OnBlockSubscriber {\n  /**\n   *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    _classPrivateFieldInitSpec(this, _provider2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _poll3, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _running, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider2, provider);\n    _classPrivateFieldSet(this, _running, false);\n    _classPrivateFieldSet(this, _poll3, blockNumber => {\n      this._poll(blockNumber, _classPrivateFieldGet(this, _provider2));\n    });\n  }\n  /**\n   *  Called on every new block.\n   */\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (_classPrivateFieldGet(this, _running)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running, true);\n    _classPrivateFieldGet(this, _poll3).call(this, -2);\n    _classPrivateFieldGet(this, _provider2).on(\"block\", _classPrivateFieldGet(this, _poll3));\n  }\n  stop() {\n    if (!_classPrivateFieldGet(this, _running)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running, false);\n    _classPrivateFieldGet(this, _provider2).off(\"block\", _classPrivateFieldGet(this, _poll3));\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.OnBlockSubscriber = OnBlockSubscriber;\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _filter = /*#__PURE__*/new WeakMap();\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\n  constructor(provider, filter) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _filter, copy(filter));\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(_classPrivateFieldGet(this, _filter));\n  }\n}\nexports.PollingOrphanSubscriber = PollingOrphanSubscriber;\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _hash = /*#__PURE__*/new WeakMap();\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%hash%%.\n   */\n  constructor(provider, hash) {\n    super(provider);\n    _classPrivateFieldInitSpec(this, _hash, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _hash, hash);\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(_classPrivateFieldGet(this, _hash));\n    if (tx) {\n      provider.emit(_classPrivateFieldGet(this, _hash), tx);\n    }\n  }\n}\nexports.PollingTransactionSubscriber = PollingTransactionSubscriber;\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nvar _provider3 = /*#__PURE__*/new WeakMap();\nvar _filter2 = /*#__PURE__*/new WeakMap();\nvar _poller2 = /*#__PURE__*/new WeakMap();\nvar _running2 = /*#__PURE__*/new WeakMap();\nvar _blockNumber2 = /*#__PURE__*/new WeakMap();\nvar _poll4 = /*#__PURE__*/new WeakSet();\nclass PollingEventSubscriber {\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%filter%%.\n   */\n  constructor(provider, _filter3) {\n    _classPrivateMethodInitSpec(this, _poll4);\n    _classPrivateFieldInitSpec(this, _provider3, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filter2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _poller2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _running2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _blockNumber2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider3, provider);\n    _classPrivateFieldSet(this, _filter2, copy(_filter3));\n    _classPrivateFieldSet(this, _poller2, _classPrivateMethodGet(this, _poll4, _poll5).bind(this));\n    _classPrivateFieldSet(this, _running2, false);\n    _classPrivateFieldSet(this, _blockNumber2, -2);\n  }\n  start() {\n    if (_classPrivateFieldGet(this, _running2)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running2, true);\n    if (_classPrivateFieldGet(this, _blockNumber2) === -2) {\n      _classPrivateFieldGet(this, _provider3).getBlockNumber().then(blockNumber => {\n        _classPrivateFieldSet(this, _blockNumber2, blockNumber);\n      });\n    }\n    _classPrivateFieldGet(this, _provider3).on(\"block\", _classPrivateFieldGet(this, _poller2));\n  }\n  stop() {\n    if (!_classPrivateFieldGet(this, _running2)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _running2, false);\n    _classPrivateFieldGet(this, _provider3).off(\"block\", _classPrivateFieldGet(this, _poller2));\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      _classPrivateFieldSet(this, _blockNumber2, -2);\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nasync function _poll5(blockNumber) {\n  // The initial block hasn't been determined yet\n  if (_classPrivateFieldGet(this, _blockNumber2) === -2) {\n    return;\n  }\n  const filter = copy(_classPrivateFieldGet(this, _filter2));\n  filter.fromBlock = _classPrivateFieldGet(this, _blockNumber2) + 1;\n  filter.toBlock = blockNumber;\n  const logs = await _classPrivateFieldGet(this, _provider3).getLogs(filter);\n  // No logs could just mean the node has not indexed them yet,\n  // so we keep a sliding window of 60 blocks to keep scanning\n  if (logs.length === 0) {\n    if (_classPrivateFieldGet(this, _blockNumber2) < blockNumber - 60) {\n      _classPrivateFieldSet(this, _blockNumber2, blockNumber - 60);\n    }\n    return;\n  }\n  for (const log of logs) {\n    _classPrivateFieldGet(this, _provider3).emit(_classPrivateFieldGet(this, _filter2), log);\n    // Only advance the block number when logs were found to\n    // account for networks (like BNB and Polygon) which may\n    // sacrifice event consistency for block event speed\n    _classPrivateFieldSet(this, _blockNumber2, log.blockNumber);\n  }\n}\nexports.PollingEventSubscriber = PollingEventSubscriber;","map":{"version":3,"sources":["../../src.ts/providers/subscriber-polling.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAKA,SAAS,IAAI,CAAC,GAAQ,EAAA;EAClB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;AAC1C;AAEA;;;;AAIG;AACH,SAAgB,oBAAoB,CAAC,QAA0B,EAAE,KAAoB,EAAA;EACjF,IAAI,KAAK,KAAK,OAAO,EAAE;IAAE,OAAO,IAAI,sBAAsB,CAAC,QAAQ,CAAC;EAAG;EACvE,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,WAAW,EAAC,KAAK,EAAE,EAAE,CAAC,EAAE;IAAE,OAAO,IAAI,4BAA4B,CAAC,QAAQ,EAAE,KAAK,CAAC;EAAG;EAEzF,CAAA,CAAA,EAAA,UAAA,CAAA,MAAM,EAAC,KAAK,EAAE,2BAA2B,EAAE,uBAAuB,EAAE;IAChE,SAAS,EAAE,sBAAsB;IAAE,IAAI,EAAE;MAAE;IAAK;GACnD,CAAC;AACN;AAPA,OAAA,CAAA,oBAAA,GAAA,oBAAA;AASA;AAEA;;;;;AAKG;AALH,IAAA,SAAA,oBAAA,OAAA;AAAA,IAAA,OAAA,oBAAA,OAAA;AAAA,IAAA,SAAA,oBAAA,OAAA;AAAA,IAAA,YAAA,oBAAA,OAAA;AAAA,IAAA,KAAA,oBAAA,OAAA;AAMA,MAAa,sBAAsB,CAAA;EAM/B;EACA;;EAGA;;AAEG;EACH,WAAA,CAAY,QAA0B,EAAA;IAAA,2BAAA,OAAA,KAAA;IAAA,0BAAA,OAAA,SAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,OAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,SAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,YAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAClC,qBAAA,KAAI,EAAA,SAAA,EAAa,QAAQ;IACzB,qBAAA,KAAI,EAAA,OAAA,EAAW,IAAI;IACnB,qBAAA,KAAI,EAAA,SAAA,EAAa,IAAI;IAErB,qBAAA,KAAI,EAAA,YAAA,EAAgB,CAAC,CAAC;EAC1B;EAEA;;AAEG;EACH,IAAI,eAAe,CAAA,EAAA;IAAa,OAAA,qBAAA,CAAO,IAAI,EAAA,SAAA;EAAY;EACvD,IAAI,eAAe,CAAC,KAAa,EAAA;IAAI,qBAAA,KAAI,EAAA,SAAA,EAAa,KAAK;EAAE;EAqC7D,KAAK,CAAA,EAAA;IACD,IAAA,qBAAA,CAAI,IAAI,EAAA,OAAA,GAAU;MAAE;IAAS;IAC7B,qBAAA,KAAI,EAAA,OAAA,EAAW,qBAAA,KAAI,EAAA,SAAA,EAAW,WAAW,CAAC,sBAAA,KAAI,EAAA,KAAA,EAAA,MAAA,EAAO,IAAI,CAAC,IAAI,CAAC,EAAA,qBAAA,CAAE,IAAI,EAAA,SAAA,EAAW;IAChF,sBAAA,KAAI,EAAA,KAAA,EAAA,MAAA,EAAA,IAAA,CAAJ,IAAI;EACR;EAEA,IAAI,CAAA,EAAA;IACA,IAAI,CAAA,qBAAA,CAAC,IAAI,EAAA,OAAA,CAAQ,EAAE;MAAE;IAAS;IAC9B,qBAAA,KAAI,EAAA,SAAA,EAAW,aAAa,CAAA,qBAAA,CAAC,IAAI,EAAA,OAAA,EAAS;IAC1C,qBAAA,KAAI,EAAA,OAAA,EAAW,IAAI;EACvB;EAEA,KAAK,CAAC,eAAyB,EAAA;IAC3B,IAAI,CAAC,IAAI,EAAE;IACX,IAAI,eAAe,EAAE;MAAE,qBAAA,KAAI,EAAA,YAAA,EAAgB,CAAC,CAAC;IAAG;EACpD;EAEA,MAAM,CAAA,EAAA;IACF,IAAI,CAAC,KAAK,EAAE;EAChB;;AACH,eAAA,OAAA,EAvDc;EACP,IAAI;IACA,MAAM,WAAW,GAAG,MAAM,qBAAA,KAAI,EAAA,SAAA,EAAW,cAAc,EAAE;IAEzD;IACA,IAAI,qBAAA,KAAI,EAAA,YAAA,MAAkB,CAAC,CAAC,EAAE;MAC1B,qBAAA,KAAI,EAAA,YAAA,EAAgB,WAAW;MAC/B;IACH;IAED;IAEA,IAAI,WAAW,KAAA,qBAAA,CAAK,IAAI,EAAA,YAAA,CAAa,EAAE;MACnC,KAAK,IAAI,CAAC,GAAG,qBAAA,KAAI,EAAA,YAAA,IAAgB,CAAC,EAAE,CAAC,IAAI,WAAW,EAAE,CAAC,EAAE,EAAE;QACvD;QACA,IAAI,qBAAA,KAAI,EAAA,OAAA,KAAY,IAAI,EAAE;UAAE;QAAS;QAErC,MAAM,qBAAA,KAAI,EAAA,SAAA,EAAW,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;MACxC;MAED,qBAAA,KAAI,EAAA,YAAA,EAAgB,WAAW;IAClC;GAEJ,CAAC,OAAO,KAAK,EAAE;IACZ;IACA;IACA;EAAA;EAGJ;EACA,IAAI,qBAAA,KAAI,EAAA,OAAA,KAAY,IAAI,EAAE;IAAE;EAAS;EAErC,qBAAA,KAAI,EAAA,OAAA,EAAW,qBAAA,KAAI,EAAA,SAAA,EAAW,WAAW,CAAC,sBAAA,KAAI,EAAA,KAAA,EAAA,MAAA,EAAO,IAAI,CAAC,IAAI,CAAC,EAAA,qBAAA,CAAE,IAAI,EAAA,SAAA,EAAW;AACpF;AA5DJ,OAAA,CAAA,sBAAA,GAAA,sBAAA;AAoFA;;;;;AAKG;AALH,IAAA,UAAA,oBAAA,OAAA;AAAA,IAAA,MAAA,oBAAA,OAAA;AAAA,IAAA,QAAA,oBAAA,OAAA;AAMA,MAAa,iBAAiB,CAAA;EAK1B;;AAEG;EACH,WAAA,CAAY,QAA0B,EAAA;IAAA,0BAAA,OAAA,UAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,MAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,QAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAClC,qBAAA,KAAI,EAAA,UAAA,EAAa,QAAQ;IACzB,qBAAA,KAAI,EAAA,QAAA,EAAY,KAAK;IACrB,qBAAA,KAAI,EAAA,MAAA,EAAU,WAAmB,IAAI;MACjC,IAAI,CAAC,KAAK,CAAC,WAAW,EAAA,qBAAA,CAAE,IAAI,EAAA,UAAA,EAAW;IAC3C,CAAC;EACL;EAEA;;AAEG;EACH,MAAM,KAAK,CAAC,WAAmB,EAAE,QAA0B,EAAA;IACvD,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC;EACrD;EAEA,KAAK,CAAA,EAAA;IACD,IAAA,qBAAA,CAAI,IAAI,EAAA,QAAA,GAAW;MAAE;IAAS;IAC9B,qBAAA,KAAI,EAAA,QAAA,EAAY,IAAI;IAEpB,qBAAA,KAAI,EAAA,MAAA,EAAA,IAAA,CAAJ,IAAI,EAAO,CAAC,CAAC;IACb,qBAAA,KAAI,EAAA,UAAA,EAAW,EAAE,CAAC,OAAO,EAAA,qBAAA,CAAE,IAAI,EAAA,MAAA,EAAO;EAC1C;EAEA,IAAI,CAAA,EAAA;IACA,IAAI,CAAA,qBAAA,CAAC,IAAI,EAAA,QAAA,CAAS,EAAE;MAAE;IAAS;IAC/B,qBAAA,KAAI,EAAA,QAAA,EAAY,KAAK;IAErB,qBAAA,KAAI,EAAA,UAAA,EAAW,GAAG,CAAC,OAAO,EAAA,qBAAA,CAAE,IAAI,EAAA,MAAA,EAAO;EAC3C;EAEA,KAAK,CAAC,eAAyB,EAAA;IAAU,IAAI,CAAC,IAAI,EAAE;EAAE;EACtD,MAAM,CAAA,EAAA;IAAW,IAAI,CAAC,KAAK,EAAE;EAAE;AAClC;AAxCD,OAAA,CAAA,iBAAA,GAAA,iBAAA;AA0CA;;;;AAIG;AAJH,IAAA,OAAA,oBAAA,OAAA;AAKA,MAAa,uBAAwB,SAAQ,iBAAiB,CAAA;EAG1D,WAAA,CAAY,QAA0B,EAAE,MAAoB,EAAA;IACxD,KAAK,CAAC,QAAQ,CAAC;IAAC,0BAAA,OAAA,OAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAChB,qBAAA,KAAI,EAAA,OAAA,EAAW,IAAI,CAAC,MAAM,CAAC;EAC/B;EAEA,MAAM,KAAK,CAAC,WAAmB,EAAE,QAA0B,EAAA;IACvD,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC;IACxB,OAAO,CAAC,GAAG,CAAA,qBAAA,CAAC,IAAI,EAAA,OAAA,EAAS;EAC7B;AACH;AAZD,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAcA;;;;;AAKG;AALH,IAAA,KAAA,oBAAA,OAAA;AAMA,MAAa,4BAA6B,SAAQ,iBAAiB,CAAA;EAG/D;;;AAGG;EACH,WAAA,CAAY,QAA0B,EAAE,IAAY,EAAA;IAChD,KAAK,CAAC,QAAQ,CAAC;IAAC,0BAAA,OAAA,KAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAChB,qBAAA,KAAI,EAAA,KAAA,EAAS,IAAI;EACrB;EAEA,MAAM,KAAK,CAAC,WAAmB,EAAE,QAA0B,EAAA;IACvD,MAAM,EAAE,GAAG,MAAM,QAAQ,CAAC,qBAAqB,CAAA,qBAAA,CAAC,IAAI,EAAA,KAAA,EAAO;IAC3D,IAAI,EAAE,EAAE;MAAE,QAAQ,CAAC,IAAI,CAAA,qBAAA,CAAC,IAAI,EAAA,KAAA,GAAQ,EAAE,CAAC;IAAG;EAC9C;AACH;AAhBD,OAAA,CAAA,4BAAA,GAAA,4BAAA;AAkBA;;;;AAIG;AAJH,IAAA,UAAA,oBAAA,OAAA;AAAA,IAAA,QAAA,oBAAA,OAAA;AAAA,IAAA,QAAA,oBAAA,OAAA;AAAA,IAAA,SAAA,oBAAA,OAAA;AAAA,IAAA,aAAA,oBAAA,OAAA;AAAA,IAAA,MAAA,oBAAA,OAAA;AAKA,MAAa,sBAAsB,CAAA;EAO/B;EACA;;EAGA;;;AAGG;EACH,WAAA,CAAY,QAA0B,EAAE,QAAmB,EAAA;IAAA,2BAAA,OAAA,MAAA;IAAA,0BAAA,OAAA,UAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,QAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,QAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,SAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,aAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IACvD,qBAAA,KAAI,EAAA,UAAA,EAAa,QAAQ;IACzB,qBAAA,KAAI,EAAA,QAAA,EAAW,IAAI,CAAC,QAAM,CAAC;IAC3B,qBAAA,KAAI,EAAA,QAAA,EAAW,sBAAA,KAAI,EAAA,MAAA,EAAA,MAAA,EAAO,IAAI,CAAC,IAAI,CAAC;IACpC,qBAAA,KAAI,EAAA,SAAA,EAAY,KAAK;IACrB,qBAAA,KAAI,EAAA,aAAA,EAAgB,CAAC,CAAC;EAC1B;EA+BA,KAAK,CAAA,EAAA;IACD,IAAA,qBAAA,CAAI,IAAI,EAAA,SAAA,GAAW;MAAE;IAAS;IAC9B,qBAAA,KAAI,EAAA,SAAA,EAAY,IAAI;IAEpB,IAAI,qBAAA,KAAI,EAAA,aAAA,MAAkB,CAAC,CAAC,EAAE;MAC1B,qBAAA,KAAI,EAAA,UAAA,EAAW,cAAc,EAAE,CAAC,IAAI,CAAE,WAAW,IAAI;QACjD,qBAAA,KAAI,EAAA,aAAA,EAAgB,WAAW;MACnC,CAAC,CAAC;IACL;IACD,qBAAA,KAAI,EAAA,UAAA,EAAW,EAAE,CAAC,OAAO,EAAA,qBAAA,CAAE,IAAI,EAAA,QAAA,EAAS;EAC5C;EAEA,IAAI,CAAA,EAAA;IACA,IAAI,CAAA,qBAAA,CAAC,IAAI,EAAA,SAAA,CAAS,EAAE;MAAE;IAAS;IAC/B,qBAAA,KAAI,EAAA,SAAA,EAAY,KAAK;IAErB,qBAAA,KAAI,EAAA,UAAA,EAAW,GAAG,CAAC,OAAO,EAAA,qBAAA,CAAE,IAAI,EAAA,QAAA,EAAS;EAC7C;EAEA,KAAK,CAAC,eAAyB,EAAA;IAC3B,IAAI,CAAC,IAAI,EAAE;IACX,IAAI,eAAe,EAAE;MAAE,qBAAA,KAAI,EAAA,aAAA,EAAgB,CAAC,CAAC;IAAG;EACpD;EAEA,MAAM,CAAA,EAAA;IACF,IAAI,CAAC,KAAK,EAAE;EAChB;;AACH,eAAA,OAxDe,WAAmB,EAAA;EAC3B;EACA,IAAI,qBAAA,KAAI,EAAA,aAAA,MAAkB,CAAC,CAAC,EAAE;IAAE;EAAS;EAEzC,MAAM,MAAM,GAAG,IAAI,CAAA,qBAAA,CAAC,IAAI,EAAA,QAAA,EAAS;EACjC,MAAM,CAAC,SAAS,GAAG,qBAAA,KAAI,EAAA,aAAA,IAAgB,CAAC;EACxC,MAAM,CAAC,OAAO,GAAG,WAAW;EAE5B,MAAM,IAAI,GAAG,MAAM,qBAAA,KAAI,EAAA,UAAA,EAAW,OAAO,CAAC,MAAM,CAAC;EAEjD;EACA;EACA,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;IACnB,IAAI,qBAAA,KAAI,EAAA,aAAA,IAAgB,WAAW,GAAG,EAAE,EAAE;MACtC,qBAAA,KAAI,EAAA,aAAA,EAAgB,WAAW,GAAG,EAAE;IACvC;IACD;EACH;EAED,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;IACpB,qBAAA,KAAI,EAAA,UAAA,EAAW,IAAI,CAAA,qBAAA,CAAC,IAAI,EAAA,QAAA,GAAU,GAAG,CAAC;IAEtC;IACA;IACA;IACA,qBAAA,KAAI,EAAA,aAAA,EAAgB,GAAG,CAAC,WAAW;EACtC;AACL;AAlDJ,OAAA,CAAA,sBAAA,GAAA,sBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nfunction getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0, index_js_1.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0, index_js_1.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\nexports.getPollingSubscriber = getPollingSubscriber;\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval() { return this.#interval; }\n    set pollingInterval(value) { this.#interval = value; }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        }\n        catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\nexports.PollingBlockSubscriber = PollingBlockSubscriber;\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber) => {\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) { this.stop(); }\n    resume() { this.start(); }\n}\nexports.OnBlockSubscriber = OnBlockSubscriber;\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\nexports.PollingOrphanSubscriber = PollingOrphanSubscriber;\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider, hash) {\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\nexports.PollingTransactionSubscriber = PollingTransactionSubscriber;\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider, filter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\nexports.PollingEventSubscriber = PollingEventSubscriber;\n//# sourceMappingURL=subscriber-polling.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}