{"ast":null,"code":"\"use strict\";\n\nvar _classPrivateFieldInitSpec = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldGet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _defineProperty = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractEventPayload = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.EventLog = void 0;\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = require(\"../providers/provider.js\");\nconst index_js_1 = require(\"../utils/index.js\");\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nclass EventLog extends provider_js_1.Log {\n  /**\n   *  The Contract Interface.\n   */\n\n  /**\n   *  The matching event.\n   */\n\n  /**\n   *  The parsed arguments passed to the event by ``emit``.\n   */\n\n  /**\n   * @_ignore:\n   */\n  constructor(log, iface, fragment) {\n    super(log, log.provider);\n    _defineProperty(this, \"interface\", void 0);\n    _defineProperty(this, \"fragment\", void 0);\n    _defineProperty(this, \"args\", void 0);\n    const args = iface.decodeEventLog(fragment, log.data, log.topics);\n    (0, index_js_1.defineProperties)(this, {\n      args,\n      fragment,\n      interface: iface\n    });\n  }\n  /**\n   *  The name of the event.\n   */\n  get eventName() {\n    return this.fragment.name;\n  }\n  /**\n   *  The signature of the event.\n   */\n  get eventSignature() {\n    return this.fragment.format();\n  }\n}\nexports.EventLog = EventLog;\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */\nvar _iface = /*#__PURE__*/new WeakMap();\nclass ContractTransactionReceipt extends provider_js_1.TransactionReceipt {\n  /**\n   *  @_ignore:\n   */\n  constructor(iface, provider, tx) {\n    super(tx, provider);\n    _classPrivateFieldInitSpec(this, _iface, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _iface, iface);\n  }\n  /**\n   *  The parsed logs for any [[Log]] which has a matching event in the\n   *  Contract ABI.\n   */\n  get logs() {\n    return super.logs.map(log => {\n      const fragment = log.topics.length ? _classPrivateFieldGet(this, _iface).getEvent(log.topics[0]) : null;\n      if (fragment) {\n        return new EventLog(log, _classPrivateFieldGet(this, _iface), fragment);\n      } else {\n        return log;\n      }\n    });\n  }\n}\nexports.ContractTransactionReceipt = ContractTransactionReceipt;\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */\nvar _iface2 = /*#__PURE__*/new WeakMap();\nclass ContractTransactionResponse extends provider_js_1.TransactionResponse {\n  /**\n   *  @_ignore:\n   */\n  constructor(iface, provider, tx) {\n    super(tx, provider);\n    _classPrivateFieldInitSpec(this, _iface2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _iface2, iface);\n  }\n  /**\n   *  Resolves once this transaction has been mined and has\n   *  %%confirms%% blocks including it (default: ``1``) with an\n   *  optional %%timeout%%.\n   *\n   *  This can resolve to ``null`` only if %%confirms%% is ``0``\n   *  and the transaction has not been mined, otherwise this will\n   *  wait until enough confirmations have completed.\n   */\n  async wait(confirms) {\n    const receipt = await super.wait();\n    if (receipt == null) {\n      return null;\n    }\n    return new ContractTransactionReceipt(_classPrivateFieldGet(this, _iface2), this.provider, receipt);\n  }\n}\nexports.ContractTransactionResponse = ContractTransactionResponse;\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */\nclass ContractUnknownEventPayload extends index_js_1.EventPayload {\n  /**\n   *  The log with no matching events.\n   */\n\n  /**\n   *  @_event:\n   */\n  constructor(contract, listener, filter, log) {\n    super(contract, listener, filter);\n    _defineProperty(this, \"log\", void 0);\n    (0, index_js_1.defineProperties)(this, {\n      log\n    });\n  }\n  /**\n   *  Resolves to the block the event occured in.\n   */\n  async getBlock() {\n    return await this.log.getBlock();\n  }\n  /**\n   *  Resolves to the transaction the event occured in.\n   */\n  async getTransaction() {\n    return await this.log.getTransaction();\n  }\n  /**\n   *  Resolves to the transaction receipt the event occured in.\n   */\n  async getTransactionReceipt() {\n    return await this.log.getTransactionReceipt();\n  }\n}\nexports.ContractUnknownEventPayload = ContractUnknownEventPayload;\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */\nclass ContractEventPayload extends ContractUnknownEventPayload {\n  /**\n   *  @_ignore:\n   */\n  constructor(contract, listener, filter, fragment, _log) {\n    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n    (0, index_js_1.defineProperties)(this, {\n      args,\n      fragment\n    });\n  }\n  /**\n   *  The event name.\n   */\n  get eventName() {\n    return this.fragment.name;\n  }\n  /**\n   *  The event signature.\n   */\n  get eventSignature() {\n    return this.fragment.format();\n  }\n}\nexports.ContractEventPayload = ContractEventPayload;","map":{"version":3,"sources":["../../src.ts/contract/wrappers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContractEventPayload = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.EventLog = void 0;\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = require(\"../providers/provider.js\");\nconst index_js_1 = require(\"../utils/index.js\");\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nclass EventLog extends provider_js_1.Log {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The matching event.\n     */\n    fragment;\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    args;\n    /**\n     * @_ignore:\n     */\n    constructor(log, iface, fragment) {\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0, index_js_1.defineProperties)(this, { args, fragment, interface: iface });\n    }\n    /**\n     *  The name of the event.\n     */\n    get eventName() { return this.fragment.name; }\n    /**\n     *  The signature of the event.\n     */\n    get eventSignature() { return this.fragment.format(); }\n}\nexports.EventLog = EventLog;\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */\nclass ContractTransactionReceipt extends provider_js_1.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */\n    get logs() {\n        return super.logs.map((log) => {\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                return new EventLog(log, this.#iface, fragment);\n            }\n            else {\n                return log;\n            }\n        });\n    }\n}\nexports.ContractTransactionReceipt = ContractTransactionReceipt;\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */\nclass ContractTransactionResponse extends provider_js_1.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(confirms) {\n        const receipt = await super.wait();\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\nexports.ContractTransactionResponse = ContractTransactionResponse;\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */\nclass ContractUnknownEventPayload extends index_js_1.EventPayload {\n    /**\n     *  The log with no matching events.\n     */\n    log;\n    /**\n     *  @_event:\n     */\n    constructor(contract, listener, filter, log) {\n        super(contract, listener, filter);\n        (0, index_js_1.defineProperties)(this, { log });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */\n    async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */\n    async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */\n    async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\nexports.ContractUnknownEventPayload = ContractUnknownEventPayload;\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */\nclass ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */\n    constructor(contract, listener, filter, fragment, _log) {\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0, index_js_1.defineProperties)(this, { args, fragment });\n    }\n    /**\n     *  The event name.\n     */\n    get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */\n    get eventSignature() {\n        return this.fragment.format();\n    }\n}\nexports.ContractEventPayload = ContractEventPayload;\n//# sourceMappingURL=wrappers.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}