{"ast":null,"code":"import { createStore } from \"vuex\";\nconst Web3 = require('web3');\nimport { ABI } from \"@/contracts/Example.abi.js\";\nimport { bytecode } from \"@/contracts/Example.bin.js\";\nexport default createStore({\n  state: {\n    web3Wallet: {},\n    wallet: {\n      address: \"\",\n      chainId: \"\",\n      chain: \"\"\n    },\n    contractAddress: \"\",\n    myContract: {},\n    txHash: \"\"\n  },\n  getters: {},\n  mutations: {},\n  actions: {\n    async connectWallet({\n      state\n    }) {\n      if (typeof window.ethereum !== 'undefined') {\n        if (window.ethereum.isMetaMask === true) {\n          if (window.ethereum.isConnected() === true) {\n            console.log(\"Metamask connected!\");\n          } else {\n            console.log(\"Metamask is not connected!\");\n            await window.ethereum.enable();\n            console.log(\"Metamask connected!\");\n          }\n          window.ethereum.request({\n            method: \"eth_requestAccounts\"\n          }).then(accounts => {\n            state.wallet.address = accounts[0];\n          });\n          state.web3Wallet = new Web3(window.ethereum);\n          state.wallet.chainId = await state.web3Wallet.eth.net.getId();\n          state.wallet.chain = await state.web3Wallet.eth.net.getNetworkType();\n          window.ethereum.on('accountsChanged', accounts => {\n            state.wallet.address = accounts[0];\n          });\n          window.ethereum.on('chainChanged', async () => {\n            state.web3Wallet = new Web3(window.ethereum);\n            state.wallet.chainId = await state.web3Wallet.eth.net.getId();\n            state.wallet.chain = await state.web3Wallet.eth.net.getNetworkType();\n          });\n        }\n      } else {\n        alert(\"Ethereum client is not installed!\");\n      }\n    },\n    // async getTransaction({state}, transactionHash){\n    //   state.web3Wallet = new Web3(window.ethereum)\n    //   return await state.web3Wallet.eth.getTransaction(transactionHash)\n    // },\n    // async sendTransaction({state}, to, value){\n    //   value = state.web3Wallet.utils.numberToHex(value)\n    //   await window.ethereum.request({\n    //     method: \"eth_sendTransaction\",\n    //     params: [{\n    //     from: state.wallet.address,\n    //     to: to,\n    //     value: value\n    //     }]\n    //     }).then(hash => {\n    //       state.txHash = hash\n    //       })\n    // },\n    async deployContract({\n      state\n    }) {\n      const receipt = await window.ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [{\n          from: state.wallet.address,\n          data: bytecode\n        }]\n      });\n\n      // Wait for the transaction to be confirmed\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const txReceipt = await window.ethereum.request({\n          method: 'eth_getTransactionReceipt',\n          params: [receipt]\n        });\n        if (txReceipt !== null) {\n          state.contractAddress = txReceipt.contractAddress;\n          console.log(\"Contract deployed at address: \", state.contractAddress);\n          break;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      state.myContract = new state.web3Wallet.eth.Contract(ABI, state.contractAddress);\n    },\n    async setX({\n      state\n    }, number) {\n      let txData = state.myContract.methods.setX(number).encodeABI();\n      await window.ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [{\n          from: state.wallet.address,\n          to: state.contractAddress,\n          data: txData\n        }]\n      }).then(hash => {\n        state.txHash = hash;\n      });\n    },\n    async setStr({\n      state\n    }, str) {\n      let txData = state.myContract.methods.setStr(str).encodeABI();\n      await window.ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [{\n          from: state.wallet.address,\n          to: state.contractAddress,\n          data: txData\n        }]\n      }).then(hash => {\n        state.txHash = hash;\n      });\n    },\n    async addElem({\n      state\n    }, elem) {\n      let txData = state.myContract.methods.addElem(elem).encodeABI();\n      await window.ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [{\n          from: state.wallet.address,\n          to: state.contractAddress,\n          data: txData\n        }]\n      }).then(hash => {\n        state.txHash = hash;\n      });\n    },\n    async getX({\n      state\n    }) {\n      console.log(state.contractAddress);\n      return await state.myContract.methods.x().call({\n        from: state.wallet.address\n      }).then(hash => {\n        state.txHash = hash;\n      });\n    },\n    async getStr({\n      state\n    }) {\n      return await state.myContract.methods.str().call({\n        from: state.wallet.address\n      }).then(hash => {\n        state.txHash = hash;\n      });\n    },\n    async getData({\n      state\n    }, index) {\n      return await state.myContract.methods.data(index).call({\n        from: state.wallet.address\n      }).then(hash => {\n        state.txHash = hash;\n      });\n    }\n  },\n  modules: {}\n});","map":{"version":3,"names":["createStore","Web3","require","ABI","bytecode","state","web3Wallet","wallet","address","chainId","chain","contractAddress","myContract","txHash","getters","mutations","actions","connectWallet","window","ethereum","isMetaMask","isConnected","console","log","enable","request","method","then","accounts","eth","net","getId","getNetworkType","on","alert","deployContract","receipt","params","from","data","txReceipt","Promise","resolve","setTimeout","Contract","setX","number","txData","methods","encodeABI","to","hash","setStr","str","addElem","elem","getX","x","call","getStr","getData","index","modules"],"sources":["/home/alan/VisualStudioProjects/BU/vue-proj1/src/store/index.js"],"sourcesContent":["import {createStore} from \"vuex\"\nconst Web3 = require('web3')\nimport {ABI} from \"@/contracts/Example.abi.js\"\nimport {bytecode} from \"@/contracts/Example.bin.js\"\n\n\n\nexport default createStore({\n  state:{\n    web3Wallet: {},\n    wallet: {\n      address: \"\",\n      chainId: \"\",\n      chain: \"\"\n    },\n    contractAddress: \"\",\n    myContract: {},\n    txHash: \"\"\n  },\n\n  getters:{\n  },\n\n  mutations:{\n  },\n\n  actions:{\n    async connectWallet({state}){\n      if (typeof window.ethereum !== 'undefined') {\n        if (window.ethereum.isMetaMask === true) {\n          if (window.ethereum.isConnected() === true) {\n            console.log(\"Metamask connected!\")\n           }\n           else {\n            console.log(\"Metamask is not connected!\")\n            await window.ethereum.enable()\n            console.log(\"Metamask connected!\")\n           }\n\n           window.ethereum.request({method: \"eth_requestAccounts\"}).then(accounts => {\n            state.wallet.address = accounts[0]\n          })\n\n            state.web3Wallet = new Web3(window.ethereum)\n\n            state.wallet.chainId = await state.web3Wallet.eth.net.getId()\n            state.wallet.chain = await state.web3Wallet.eth.net.getNetworkType()\n\n          window.ethereum.on('accountsChanged', (accounts) =>{\n            state.wallet.address = accounts[0]\n          })\n\n          window.ethereum.on('chainChanged', async () =>{\n            state.web3Wallet = new Web3(window.ethereum)\n            state.wallet.chainId = await state.web3Wallet.eth.net.getId()\n            state.wallet.chain = await state.web3Wallet.eth.net.getNetworkType()\n          })\n         }         \n       }\n        else{\n        alert(\"Ethereum client is not installed!\")\n        }\n    },\n    // async getTransaction({state}, transactionHash){\n    //   state.web3Wallet = new Web3(window.ethereum)\n    //   return await state.web3Wallet.eth.getTransaction(transactionHash)\n    // },\n    // async sendTransaction({state}, to, value){\n    //   value = state.web3Wallet.utils.numberToHex(value)\n    //   await window.ethereum.request({\n    //     method: \"eth_sendTransaction\",\n    //     params: [{\n    //     from: state.wallet.address,\n    //     to: to,\n    //     value: value\n    //     }]\n    //     }).then(hash => {\n    //       state.txHash = hash\n    //       })\n    // },\n    async deployContract({state}){\n      const receipt = await window.ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [{\n          from: state.wallet.address,\n          data: bytecode\n        }]\n      })\n      \n      // Wait for the transaction to be confirmed\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const txReceipt = await window.ethereum.request({\n          method: 'eth_getTransactionReceipt',\n          params: [receipt]\n        });\n      \n        if (txReceipt !== null) {\n          state.contractAddress = txReceipt.contractAddress;\n          console.log(\"Contract deployed at address: \", state.contractAddress);\n          break;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      state.myContract = new state.web3Wallet.eth.Contract(ABI, state.contractAddress)\n    },\n    async setX({state}, number){\n        let txData = state.myContract.methods.setX(number).encodeABI()\n\n        await window.ethereum.request({\n          method: \"eth_sendTransaction\",\n          params: [{\n            from: state.wallet.address,\n            to: state.contractAddress,\n            data: txData\n          }]\n          }).then(hash => {\n            state.txHash = hash\n            })\n    },\n    async setStr({state}, str){\n      let txData = state.myContract.methods.setStr(str).encodeABI()\n\n      await window.ethereum.request({\n        method: \"eth_sendTransaction\",\n        params: [{\n          from: state.wallet.address,\n          to: state.contractAddress,\n          data: txData\n        }]\n        }).then(hash => {\n          state.txHash = hash\n          })\n  },\n  async addElem({state}, elem){\n    let txData = state.myContract.methods.addElem(elem).encodeABI()\n\n    await window.ethereum.request({\n      method: \"eth_sendTransaction\",\n      params: [{\n        from: state.wallet.address,\n        to: state.contractAddress,\n        data: txData\n      }]\n      }).then(hash => {\n        state.txHash = hash\n        })\n},\n\n  async getX({state}){\n    console.log(state.contractAddress)\n    return await state.myContract.methods.x().call({from: state.wallet.address}).then(hash => {\n      state.txHash = hash\n      })\n  },\n  async getStr({state}){\n    return await state.myContract.methods.str().call({from: state.wallet.address}).then(hash => {\n      state.txHash = hash\n      })\n  },\n  async getData({state}, index){\n    return await state.myContract.methods.data(index).call({from: state.wallet.address}).then(hash => {\n      state.txHash = hash\n      })\n  },\n\n  },\n\n  modules:{\n\n  }\n})"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}