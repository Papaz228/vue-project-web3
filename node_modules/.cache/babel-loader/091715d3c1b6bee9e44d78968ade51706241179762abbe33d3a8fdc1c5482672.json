{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recoverAddress = exports.computeAddress = void 0;\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nfunction computeAddress(key) {\n  let pubkey;\n  if (typeof key === \"string\") {\n    pubkey = index_js_2.SigningKey.computePublicKey(key, false);\n  } else {\n    pubkey = key.publicKey;\n  }\n  return (0, index_js_1.getAddress)((0, index_js_2.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\nexports.computeAddress = computeAddress;\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nfunction recoverAddress(digest, signature) {\n  return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));\n}\nexports.recoverAddress = recoverAddress;","map":{"version":3,"sources":["../../src.ts/transaction/address.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AAKA;;;;AAIG;AACH,SAAgB,cAAc,CAAC,GAAwB,EAAA;EACnD,IAAI,MAAc;EAClB,IAAI,OAAO,GAAI,KAAK,QAAQ,EAAE;IAC1B,MAAM,GAAG,UAAA,CAAA,UAAU,CAAC,gBAAgB,CAAC,GAAG,EAAE,KAAK,CAAC;GACnD,MAAM;IACH,MAAM,GAAG,GAAG,CAAC,SAAS;EACzB;EACD,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,UAAU,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,SAAS,EAAC,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;AAC1E;AARA,OAAA,CAAA,cAAA,GAAA,cAAA;AAUA;;;AAGG;AACH,SAAgB,cAAc,CAAC,MAAiB,EAAE,SAAwB,EAAA;EACtE,OAAO,cAAc,CAAC,UAAA,CAAA,UAAU,CAAC,gBAAgB,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;AACzE;AAFA,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.recoverAddress = exports.computeAddress = void 0;\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nfunction computeAddress(key) {\n    let pubkey;\n    if (typeof (key) === \"string\") {\n        pubkey = index_js_2.SigningKey.computePublicKey(key, false);\n    }\n    else {\n        pubkey = key.publicKey;\n    }\n    return (0, index_js_1.getAddress)((0, index_js_2.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\nexports.computeAddress = computeAddress;\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nfunction recoverAddress(digest, signature) {\n    return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));\n}\nexports.recoverAddress = recoverAddress;\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}