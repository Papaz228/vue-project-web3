{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nconst address_js_1 = require(\"./address.js\");\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nfunction isAddressable(value) {\n  return value && typeof value.getAddress === \"function\";\n}\nexports.isAddressable = isAddressable;\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nfunction isAddress(value) {\n  try {\n    (0, address_js_1.getAddress)(value);\n    return true;\n  } catch (error) {}\n  return false;\n}\nexports.isAddress = isAddress;\nasync function checkAddress(target, promise) {\n  const result = await promise;\n  if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n    (0, index_js_1.assert)(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n      value: target\n    });\n    (0, index_js_1.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n  }\n  return (0, address_js_1.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nfunction resolveAddress(target, resolver) {\n  if (typeof target === \"string\") {\n    if (target.match(/^0x[0-9a-f]{40}$/i)) {\n      return (0, address_js_1.getAddress)(target);\n    }\n    (0, index_js_1.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"resolveName\"\n    });\n    return checkAddress(target, resolver.resolveName(target));\n  } else if (isAddressable(target)) {\n    return checkAddress(target, target.getAddress());\n  } else if (target && typeof target.then === \"function\") {\n    return checkAddress(target, target);\n  }\n  (0, index_js_1.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n}\nexports.resolveAddress = resolveAddress;","map":{"version":3,"sources":["../../src.ts/address/checks.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAEA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAKA;;;;;;;;;;;;;AAaG;AACH,SAAgB,aAAa,CAAC,KAAU,EAAA;EACpC,OAAQ,KAAK,IAAI,OAAO,KAAK,CAAC,UAAW,KAAK,UAAU;AAC5D;AAFA,OAAA,CAAA,aAAA,GAAA,aAAA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;AAwBG;AACH,SAAgB,SAAS,CAAC,KAAU,EAAA;EAChC,IAAI;IACA,CAAA,CAAA,EAAA,YAAA,CAAA,UAAU,EAAC,KAAK,CAAC;IACjB,OAAO,IAAI;GACd,CAAC,OAAO,KAAK,EAAE,CAAA;EAChB,OAAO,KAAK;AAChB;AANA,OAAA,CAAA,SAAA,GAAA,SAAA;AAQA,eAAe,YAAY,CAAC,MAAW,EAAE,OAA+B,EAAA;EACpE,MAAM,MAAM,GAAG,MAAM,OAAO;EAC5B,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM,KAAK,4CAA4C,EAAE;IAC3E,CAAA,CAAA,EAAA,UAAA,CAAA,MAAM,EAAC,OAAO,MAAO,KAAK,QAAQ,EAAE,mBAAmB,EAAE,mBAAmB,EAAE;MAAE,KAAK,EAAE;IAAM,CAAE,CAAC;IAChG,CAAA,CAAA,EAAA,UAAA,CAAA,cAAc,EAAC,KAAK,EAAE,+DAA+D,EAAE,QAAQ,EAAE,MAAM,CAAC;EAC3G;EACD,OAAO,CAAA,CAAA,EAAA,YAAA,CAAA,UAAU,EAAC,MAAM,CAAC;AAC7B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCG;AACH,SAAgB,cAAc,CAAC,MAAmB,EAAE,QAA8B,EAAA;EAE9E,IAAI,OAAO,MAAO,KAAK,QAAQ,EAAE;IAC7B,IAAI,MAAM,CAAC,KAAK,CAAC,mBAAmB,CAAC,EAAE;MAAE,OAAO,CAAA,CAAA,EAAA,YAAA,CAAA,UAAU,EAAC,MAAM,CAAC;IAAG;IAErE,CAAA,CAAA,EAAA,UAAA,CAAA,MAAM,EAAC,QAAQ,IAAI,IAAI,EAAE,oCAAoC,EACzD,uBAAuB,EAAE;MAAE,SAAS,EAAE;IAAa,CAAE,CAAC;IAE1D,OAAO,YAAY,CAAC,MAAM,EAAE,QAAQ,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;GAE5D,MAAM,IAAI,aAAa,CAAC,MAAM,CAAC,EAAE;IAC9B,OAAO,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC,UAAU,EAAE,CAAC;GAEnD,MAAM,IAAI,MAAM,IAAI,OAAO,MAAM,CAAC,IAAK,KAAK,UAAU,EAAE;IACrD,OAAO,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC;EACtC;EAED,CAAA,CAAA,EAAA,UAAA,CAAA,cAAc,EAAC,KAAK,EAAE,+BAA+B,EAAE,QAAQ,EAAE,MAAM,CAAC;AAC5E;AAlBA,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nconst address_js_1 = require(\"./address.js\");\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nfunction isAddressable(value) {\n    return (value && typeof (value.getAddress) === \"function\");\n}\nexports.isAddressable = isAddressable;\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nfunction isAddress(value) {\n    try {\n        (0, address_js_1.getAddress)(value);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexports.isAddress = isAddress;\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0, index_js_1.assert)(typeof (target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\n        (0, index_js_1.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0, address_js_1.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nfunction resolveAddress(target, resolver) {\n    if (typeof (target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0, address_js_1.getAddress)(target);\n        }\n        (0, index_js_1.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\n        return checkAddress(target, resolver.resolveName(target));\n    }\n    else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    }\n    else if (target && typeof (target.then) === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n}\nexports.resolveAddress = resolveAddress;\n//# sourceMappingURL=checks.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}