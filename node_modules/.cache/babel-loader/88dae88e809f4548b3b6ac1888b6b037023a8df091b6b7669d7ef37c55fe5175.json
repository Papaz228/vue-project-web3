{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/esnext.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/esnext.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/esnext.typed-array.with.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../utils/index.js\");\nconst ens_normalize_1 = require(\"@adraffy/ens-normalize\");\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n  (0, index_js_2.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n  return comp;\n}\nfunction ensNameSplit(name) {\n  const bytes = (0, index_js_2.toUtf8Bytes)(ensNormalize(name));\n  const comps = [];\n  if (name.length === 0) {\n    return comps;\n  }\n  let last = 0;\n  for (let i = 0; i < bytes.length; i++) {\n    const d = bytes[i];\n    // A separator (i.e. \".\"); copy this component\n    if (d === 0x2e) {\n      comps.push(checkComponent(bytes.slice(last, i)));\n      last = i + 1;\n    }\n  }\n  // There was a stray separator at the end of the name\n  (0, index_js_2.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n  comps.push(checkComponent(bytes.slice(last)));\n  return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */\nfunction ensNormalize(name) {\n  try {\n    return (0, ens_normalize_1.ens_normalize)(name);\n  } catch (error) {\n    (0, index_js_2.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n  }\n}\nexports.ensNormalize = ensNormalize;\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */\nfunction isValidName(name) {\n  try {\n    return ensNameSplit(name).length !== 0;\n  } catch (error) {}\n  return false;\n}\nexports.isValidName = isValidName;\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */\nfunction namehash(name) {\n  (0, index_js_2.assertArgument)(typeof name === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n  let result = Zeros;\n  const comps = ensNameSplit(name);\n  while (comps.length) {\n    result = (0, index_js_1.keccak256)((0, index_js_2.concat)([result, (0, index_js_1.keccak256)(comps.pop())]));\n  }\n  return (0, index_js_2.hexlify)(result);\n}\nexports.namehash = namehash;\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */\nfunction dnsEncode(name) {\n  return (0, index_js_2.hexlify)((0, index_js_2.concat)(ensNameSplit(name).map(comp => {\n    // DNS does not allow components over 63 bytes in length\n    if (comp.length > 63) {\n      throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n    }\n    const bytes = new Uint8Array(comp.length + 1);\n    bytes.set(comp, 1);\n    bytes[0] = bytes.length - 1;\n    return bytes;\n  }))) + \"00\";\n}\nexports.dnsEncode = dnsEncode;","map":{"version":3,"sources":["../../src.ts/hash/namehash.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../utils/index.js\");\nconst ens_normalize_1 = require(\"@adraffy/ens-normalize\");\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0, index_js_2.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0, index_js_2.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0, index_js_2.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */\nfunction ensNormalize(name) {\n    try {\n        return (0, ens_normalize_1.ens_normalize)(name);\n    }\n    catch (error) {\n        (0, index_js_2.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n    }\n}\nexports.ensNormalize = ensNormalize;\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */\nfunction isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nexports.isValidName = isValidName;\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */\nfunction namehash(name) {\n    (0, index_js_2.assertArgument)(typeof (name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = (0, index_js_1.keccak256)((0, index_js_2.concat)([result, (0, index_js_1.keccak256)((comps.pop()))]));\n    }\n    return (0, index_js_2.hexlify)(result);\n}\nexports.namehash = namehash;\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */\nfunction dnsEncode(name) {\n    return (0, index_js_2.hexlify)((0, index_js_2.concat)(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\nexports.dnsEncode = dnsEncode;\n//# sourceMappingURL=namehash.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}