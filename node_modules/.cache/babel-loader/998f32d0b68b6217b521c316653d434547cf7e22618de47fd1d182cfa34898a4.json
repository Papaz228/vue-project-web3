{"ast":null,"code":"\"use strict\";\n\nvar _classStaticPrivateMethodGet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classStaticPrivateMethodGet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Wallet = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../utils/index.js\");\nconst base_wallet_js_1 = require(\"./base-wallet.js\");\nconst hdwallet_js_1 = require(\"./hdwallet.js\");\nconst json_crowdsale_js_1 = require(\"./json-crowdsale.js\");\nconst json_keystore_js_1 = require(\"./json-keystore.js\");\nconst mnemonic_js_1 = require(\"./mnemonic.js\");\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, duration);\n  });\n}\n/**\n *  A **Wallet** manages a single private key which is used to sign\n *  transactions, messages and other common payloads.\n *\n *  This class is generally the main entry point for developers\n *  that wish to use a private key directly, as it can create\n *  instances from a large variety of common sources, including\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\n *  wallets.\n */\nclass Wallet extends base_wallet_js_1.BaseWallet {\n  /**\n   *  Create a new wallet for the %%privateKey%%, optionally connected\n   *  to %%provider%%.\n   */\n  constructor(key, provider) {\n    if (typeof key === \"string\" && !key.startsWith(\"0x\")) {\n      key = \"0x\" + key;\n    }\n    let signingKey = typeof key === \"string\" ? new index_js_1.SigningKey(key) : key;\n    super(signingKey, provider);\n  }\n  connect(provider) {\n    return new Wallet(this.signingKey, provider);\n  }\n  /**\n   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n   *  %%password%%.\n   *\n   *  If %%progressCallback%% is specified, it will receive periodic\n   *  updates as the encryption process progreses.\n   */\n  async encrypt(password, progressCallback) {\n    const account = {\n      address: this.address,\n      privateKey: this.privateKey\n    };\n    return await (0, json_keystore_js_1.encryptKeystoreJson)(account, password, {\n      progressCallback\n    });\n  }\n  /**\n   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n   *  %%password%%.\n   *\n   *  It is preferred to use the [async version](encrypt) instead,\n   *  which allows a [[ProgressCallback]] to keep the user informed.\n   *\n   *  This method will block the event loop (freezing all UI) until\n   *  it is complete, which may be a non-trivial duration.\n   */\n  encryptSync(password) {\n    const account = {\n      address: this.address,\n      privateKey: this.privateKey\n    };\n    return (0, json_keystore_js_1.encryptKeystoreJsonSync)(account, password);\n  }\n  /**\n   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\n   *  with %%password%%.\n   *\n   *  If %%progress%% is provided, it is called periodically during\n   *  decryption so that any UI can be updated.\n   */\n  static async fromEncryptedJson(json, password, progress) {\n    let account = null;\n    if ((0, json_keystore_js_1.isKeystoreJson)(json)) {\n      account = await (0, json_keystore_js_1.decryptKeystoreJson)(json, password, progress);\n    } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {\n      if (progress) {\n        progress(0);\n        await stall(0);\n      }\n      account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);\n      if (progress) {\n        progress(1);\n        await stall(0);\n      }\n    }\n    return _classStaticPrivateMethodGet(Wallet, Wallet, _fromAccount).call(Wallet, account);\n  }\n  /**\n   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\n   *\n   *  The [[fromEncryptedJson]] method is preferred, as this method\n   *  will lock up and freeze the UI during decryption, which may take\n   *  some time.\n   */\n  static fromEncryptedJsonSync(json, password) {\n    let account = null;\n    if ((0, json_keystore_js_1.isKeystoreJson)(json)) {\n      account = (0, json_keystore_js_1.decryptKeystoreJsonSync)(json, password);\n    } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {\n      account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);\n    } else {\n      (0, index_js_2.assertArgument)(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n    }\n    return _classStaticPrivateMethodGet(Wallet, Wallet, _fromAccount).call(Wallet, account);\n  }\n  /**\n   *  Creates a new random [[HDNodeWallet]] using the avavilable\n   *  [cryptographic random source](randomBytes).\n   *\n   *  If there is no crytographic random source, this will throw.\n   */\n  static createRandom(provider) {\n    const wallet = hdwallet_js_1.HDNodeWallet.createRandom();\n    if (provider) {\n      return wallet.connect(provider);\n    }\n    return wallet;\n  }\n  /**\n   *  Creates a [[HDNodeWallet]] for %%phrase%%.\n   */\n  static fromPhrase(phrase, provider) {\n    const wallet = hdwallet_js_1.HDNodeWallet.fromPhrase(phrase);\n    if (provider) {\n      return wallet.connect(provider);\n    }\n    return wallet;\n  }\n}\nfunction _fromAccount(account) {\n  (0, index_js_2.assertArgument)(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n  if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\n    const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy(account.mnemonic.entropy);\n    const wallet = hdwallet_js_1.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\n    if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\n      return wallet;\n    }\n    console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\n  }\n  const wallet = new Wallet(account.privateKey);\n  (0, index_js_2.assertArgument)(wallet.address === account.address, \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\n  return wallet;\n}\nexports.Wallet = Wallet;","map":{"version":3,"sources":["../../src.ts/wallet/wallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Wallet = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../utils/index.js\");\nconst base_wallet_js_1 = require(\"./base-wallet.js\");\nconst hdwallet_js_1 = require(\"./hdwallet.js\");\nconst json_crowdsale_js_1 = require(\"./json-crowdsale.js\");\nconst json_keystore_js_1 = require(\"./json-keystore.js\");\nconst mnemonic_js_1 = require(\"./mnemonic.js\");\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\n}\n/**\n *  A **Wallet** manages a single private key which is used to sign\n *  transactions, messages and other common payloads.\n *\n *  This class is generally the main entry point for developers\n *  that wish to use a private key directly, as it can create\n *  instances from a large variety of common sources, including\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\n *  wallets.\n */\nclass Wallet extends base_wallet_js_1.BaseWallet {\n    /**\n     *  Create a new wallet for the %%privateKey%%, optionally connected\n     *  to %%provider%%.\n     */\n    constructor(key, provider) {\n        if (typeof (key) === \"string\" && !key.startsWith(\"0x\")) {\n            key = \"0x\" + key;\n        }\n        let signingKey = (typeof (key) === \"string\") ? new index_js_1.SigningKey(key) : key;\n        super(signingKey, provider);\n    }\n    connect(provider) {\n        return new Wallet(this.signingKey, provider);\n    }\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */\n    async encrypt(password, progressCallback) {\n        const account = { address: this.address, privateKey: this.privateKey };\n        return await (0, json_keystore_js_1.encryptKeystoreJson)(account, password, { progressCallback });\n    }\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */\n    encryptSync(password) {\n        const account = { address: this.address, privateKey: this.privateKey };\n        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(account, password);\n    }\n    static #fromAccount(account) {\n        (0, index_js_2.assertArgument)(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\n            const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy(account.mnemonic.entropy);\n            const wallet = hdwallet_js_1.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\n            if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\n                return wallet;\n            }\n            console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\n        }\n        const wallet = new Wallet(account.privateKey);\n        (0, index_js_2.assertArgument)(wallet.address === account.address, \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\n        return wallet;\n    }\n    /**\n     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\n     *  with %%password%%.\n     *\n     *  If %%progress%% is provided, it is called periodically during\n     *  decryption so that any UI can be updated.\n     */\n    static async fromEncryptedJson(json, password, progress) {\n        let account = null;\n        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {\n            account = await (0, json_keystore_js_1.decryptKeystoreJson)(json, password, progress);\n        }\n        else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {\n            if (progress) {\n                progress(0);\n                await stall(0);\n            }\n            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);\n            if (progress) {\n                progress(1);\n                await stall(0);\n            }\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\n     *\n     *  The [[fromEncryptedJson]] method is preferred, as this method\n     *  will lock up and freeze the UI during decryption, which may take\n     *  some time.\n     */\n    static fromEncryptedJsonSync(json, password) {\n        let account = null;\n        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {\n            account = (0, json_keystore_js_1.decryptKeystoreJsonSync)(json, password);\n        }\n        else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {\n            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);\n        }\n        else {\n            (0, index_js_2.assertArgument)(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a new random [[HDNodeWallet]] using the avavilable\n     *  [cryptographic random source](randomBytes).\n     *\n     *  If there is no crytographic random source, this will throw.\n     */\n    static createRandom(provider) {\n        const wallet = hdwallet_js_1.HDNodeWallet.createRandom();\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n    /**\n     *  Creates a [[HDNodeWallet]] for %%phrase%%.\n     */\n    static fromPhrase(phrase, provider) {\n        const wallet = hdwallet_js_1.HDNodeWallet.fromPhrase(phrase);\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n}\nexports.Wallet = Wallet;\n//# sourceMappingURL=wallet.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}