{"ast":null,"code":"\"use strict\";\n\nvar _classPrivateFieldInitSpec = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _defineProperty = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateFieldGet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NonceManager = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nconst abstract_signer_js_1 = require(\"./abstract-signer.js\");\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nvar _noncePromise = /*#__PURE__*/new WeakMap();\nvar _delta = /*#__PURE__*/new WeakMap();\nclass NonceManager extends abstract_signer_js_1.AbstractSigner {\n  /**\n   *  The Signer being managed.\n   */\n\n  /**\n   *  Creates a new **NonceManager** to manage %%signer%%.\n   */\n  constructor(signer) {\n    super(signer.provider);\n    _defineProperty(this, \"signer\", void 0);\n    _classPrivateFieldInitSpec(this, _noncePromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _delta, {\n      writable: true,\n      value: void 0\n    });\n    (0, index_js_1.defineProperties)(this, {\n      signer\n    });\n    _classPrivateFieldSet(this, _noncePromise, null);\n    _classPrivateFieldSet(this, _delta, 0);\n  }\n  async getAddress() {\n    return this.signer.getAddress();\n  }\n  connect(provider) {\n    return new NonceManager(this.signer.connect(provider));\n  }\n  async getNonce(blockTag) {\n    if (blockTag === \"pending\") {\n      if (_classPrivateFieldGet(this, _noncePromise) == null) {\n        _classPrivateFieldSet(this, _noncePromise, super.getNonce(\"pending\"));\n      }\n      const delta = _classPrivateFieldGet(this, _delta);\n      return (await _classPrivateFieldGet(this, _noncePromise)) + delta;\n    }\n    return super.getNonce(blockTag);\n  }\n  /**\n   *  Manually increment the nonce. This may be useful when managng\n   *  offline transactions.\n   */\n  increment() {\n    var _this$delta, _this$delta2;\n    _classPrivateFieldSet(this, _delta, (_this$delta = _classPrivateFieldGet(this, _delta), _this$delta2 = _this$delta++, _this$delta)), _this$delta2;\n  }\n  /**\n   *  Resets the nonce, causing the **NonceManager** to reload the current\n   *  nonce from the blockchain on the next transaction.\n   */\n  reset() {\n    _classPrivateFieldSet(this, _delta, 0);\n    _classPrivateFieldSet(this, _noncePromise, null);\n  }\n  async sendTransaction(tx) {\n    const noncePromise = this.getNonce(\"pending\");\n    this.increment();\n    tx = await this.signer.populateTransaction(tx);\n    tx.nonce = await noncePromise;\n    // @TODO: Maybe handle interesting/recoverable errors?\n    // Like don't increment if the tx was certainly not sent\n    return await this.signer.sendTransaction(tx);\n  }\n  signTransaction(tx) {\n    return this.signer.signTransaction(tx);\n  }\n  signMessage(message) {\n    return this.signer.signMessage(message);\n  }\n  signTypedData(domain, types, value) {\n    return this.signer.signTypedData(domain, types, value);\n  }\n}\nexports.NonceManager = NonceManager;","map":{"version":3,"sources":["../../src.ts/providers/signer-noncemanager.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AACA,MAAA,oBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;AAUA;;;;AAIG;AAJH,IAAA,aAAA,oBAAA,OAAA;AAAA,IAAA,MAAA,oBAAA,OAAA;AAKA,MAAa,YAAa,SAAQ,oBAAA,CAAA,cAAc,CAAA;EAC5C;;AAEG;;EAMH;;AAEG;EACH,WAAA,CAAY,MAAc,EAAA;IACtB,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC;IAAC,eAAA;IAAA,0BAAA,OAAA,aAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IAAA,0BAAA,OAAA,MAAA;MAAA,QAAA;MAAA,KAAA;IAAA;IACvB,CAAA,CAAA,EAAA,UAAA,CAAA,gBAAgB,EAAe,IAAI,EAAE;MAAE;IAAM,CAAE,CAAC;IAEhD,qBAAA,KAAI,EAAA,aAAA,EAAiB,IAAI;IACzB,qBAAA,KAAI,EAAA,MAAA,EAAU,CAAC;EACnB;EAEA,MAAM,UAAU,CAAA,EAAA;IACZ,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;EACnC;EAEA,OAAO,CAAC,QAAyB,EAAA;IAC7B,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;EAC1D;EAEA,MAAM,QAAQ,CAAC,QAAmB,EAAA;IAC9B,IAAI,QAAQ,KAAK,SAAS,EAAE;MACxB,IAAI,qBAAA,KAAI,EAAA,aAAA,KAAkB,IAAI,EAAE;QAC5B,qBAAA,KAAI,EAAA,aAAA,EAAiB,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC;MACjD;MAED,MAAM,KAAK,GAAA,qBAAA,CAAG,IAAI,EAAA,MAAA,CAAO;MACzB,OAAO,CAAC,MAAA,qBAAA,CAAM,IAAI,EAAA,aAAA,CAAc,IAAI,KAAK;IAC5C;IAED,OAAO,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;EACnC;EAEA;;;AAGG;EACH,SAAS,CAAA,EAAA;IAAA,IAAA,WAAA,EAAA,YAAA;IACL,qBAAA,KAAI,EAAA,MAAA,GAAA,WAAA,GAAA,qBAAA,CAAJ,IAAI,EAAA,MAAA,GAAA,YAAA,GAAA,WAAA,IAAA,WAAA,IAAA,YAAA;EACR;EAEA;;;AAGG;EACH,KAAK,CAAA,EAAA;IACD,qBAAA,KAAI,EAAA,MAAA,EAAU,CAAC;IACf,qBAAA,KAAI,EAAA,aAAA,EAAiB,IAAI;EAC7B;EAEA,MAAM,eAAe,CAAC,EAAsB,EAAA;IACxC,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;IAC7C,IAAI,CAAC,SAAS,EAAE;IAEhB,EAAE,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,EAAE,CAAC;IAC9C,EAAE,CAAC,KAAK,GAAG,MAAM,YAAY;IAE7B;IACA;IACA,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE,CAAC;EAChD;EAEA,eAAe,CAAC,EAAsB,EAAA;IAClC,OAAO,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE,CAAC;EAC1C;EAEA,WAAW,CAAC,OAA4B,EAAA;IACpC,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC;EAC3C;EAEA,aAAa,CAAC,MAAuB,EAAE,KAA4C,EAAE,KAA0B,EAAA;IAC3G,OAAO,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC;EAC1D;AACH;AAjFD,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NonceManager = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nconst abstract_signer_js_1 = require(\"./abstract-signer.js\");\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nclass NonceManager extends abstract_signer_js_1.AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer;\n    #noncePromise;\n    #delta;\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer) {\n        super(signer.provider);\n        (0, index_js_1.defineProperties)(this, { signer });\n        this.#noncePromise = null;\n        this.#delta = 0;\n    }\n    async getAddress() {\n        return this.signer.getAddress();\n    }\n    connect(provider) {\n        return new NonceManager(this.signer.connect(provider));\n    }\n    async getNonce(blockTag) {\n        if (blockTag === \"pending\") {\n            if (this.#noncePromise == null) {\n                this.#noncePromise = super.getNonce(\"pending\");\n            }\n            const delta = this.#delta;\n            return (await this.#noncePromise) + delta;\n        }\n        return super.getNonce(blockTag);\n    }\n    /**\n     *  Manually increment the nonce. This may be useful when managng\n     *  offline transactions.\n     */\n    increment() {\n        this.#delta++;\n    }\n    /**\n     *  Resets the nonce, causing the **NonceManager** to reload the current\n     *  nonce from the blockchain on the next transaction.\n     */\n    reset() {\n        this.#delta = 0;\n        this.#noncePromise = null;\n    }\n    async sendTransaction(tx) {\n        const noncePromise = this.getNonce(\"pending\");\n        this.increment();\n        tx = await this.signer.populateTransaction(tx);\n        tx.nonce = await noncePromise;\n        // @TODO: Maybe handle interesting/recoverable errors?\n        // Like don't increment if the tx was certainly not sent\n        return await this.signer.sendTransaction(tx);\n    }\n    signTransaction(tx) {\n        return this.signer.signTransaction(tx);\n    }\n    signMessage(message) {\n        return this.signer.signMessage(message);\n    }\n    signTypedData(domain, types, value) {\n        return this.signer.signTypedData(domain, types, value);\n    }\n}\nexports.NonceManager = NonceManager;\n//# sourceMappingURL=signer-noncemanager.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}