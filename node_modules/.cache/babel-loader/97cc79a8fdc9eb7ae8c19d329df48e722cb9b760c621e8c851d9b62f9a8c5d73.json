{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nrequire(\"core-js/modules/esnext.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/esnext.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/esnext.typed-array.with.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractFactory = void 0;\nconst index_js_1 = require(\"../abi/index.js\");\nconst index_js_2 = require(\"../address/index.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst contract_js_1 = require(\"./contract.js\");\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */\nclass ContractFactory {\n  /**\n   *  The Contract Interface.\n   */\n\n  /**\n   *  The Contract deployment bytecode. Often called the initcode.\n   */\n\n  /**\n   *  The ContractRunner to deploy the Contract as.\n   */\n\n  /**\n   *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n   *  optionally connected to %%runner%%.\n   *\n   *  The %%bytecode%% may be the ``bytecode`` property within the\n   *  standard Solidity JSON output.\n   */\n  constructor(abi, bytecode, runner) {\n    _defineProperty(this, \"interface\", void 0);\n    _defineProperty(this, \"bytecode\", void 0);\n    _defineProperty(this, \"runner\", void 0);\n    const iface = index_js_1.Interface.from(abi);\n    // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n    if (bytecode instanceof Uint8Array) {\n      bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n    } else {\n      if (typeof bytecode === \"object\") {\n        bytecode = bytecode.object;\n      }\n      if (!bytecode.startsWith(\"0x\")) {\n        bytecode = \"0x\" + bytecode;\n      }\n      bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n    }\n    (0, index_js_3.defineProperties)(this, {\n      bytecode,\n      interface: iface,\n      runner: runner || null\n    });\n  }\n  attach(target) {\n    return new contract_js_1.BaseContract(target, this.interface, this.runner);\n  }\n  /**\n   *  Resolves to the transaction to deploy the contract, passing %%args%%\n   *  into the constructor.\n   */\n  async getDeployTransaction(...args) {\n    let overrides = {};\n    const fragment = this.interface.deploy;\n    if (fragment.inputs.length + 1 === args.length) {\n      overrides = await (0, contract_js_1.copyOverrides)(args.pop());\n    }\n    if (fragment.inputs.length !== args.length) {\n      throw new Error(\"incorrect number of arguments to constructor\");\n    }\n    const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);\n    const data = (0, index_js_3.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);\n    return Object.assign({}, overrides, {\n      data\n    });\n  }\n  /**\n   *  Resolves to the Contract deployed by passing %%args%% into the\n   *  constructor.\n   *\n   *  This will resovle to the Contract before it has been deployed to the\n   *  network, so the [[BaseContract-waitForDeployment]] should be used before\n   *  sending any transactions to it.\n   */\n  async deploy(...args) {\n    const tx = await this.getDeployTransaction(...args);\n    (0, index_js_3.assert)(this.runner && typeof this.runner.sendTransaction === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const sentTx = await this.runner.sendTransaction(tx);\n    const address = (0, index_js_2.getCreateAddress)(sentTx);\n    return new contract_js_1.BaseContract(address, this.interface, this.runner, sentTx);\n  }\n  /**\n   *  Return a new **ContractFactory** with the same ABI and bytecode,\n   *  but connected to %%runner%%.\n   */\n  connect(runner) {\n    return new ContractFactory(this.interface, this.bytecode, runner);\n  }\n  /**\n   *  Create a new **ContractFactory** from the standard Solidity JSON output.\n   */\n  static fromSolidity(output, runner) {\n    (0, index_js_3.assertArgument)(output != null, \"bad compiler output\", \"output\", output);\n    if (typeof output === \"string\") {\n      output = JSON.parse(output);\n    }\n    const abi = output.abi;\n    let bytecode = \"\";\n    if (output.bytecode) {\n      bytecode = output.bytecode;\n    } else if (output.evm && output.evm.bytecode) {\n      bytecode = output.evm.bytecode;\n    }\n    return new this(abi, bytecode, runner);\n  }\n}\nexports.ContractFactory = ContractFactory;","map":{"version":3,"sources":["../../src.ts/contract/factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContractFactory = void 0;\nconst index_js_1 = require(\"../abi/index.js\");\nconst index_js_2 = require(\"../address/index.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst contract_js_1 = require(\"./contract.js\");\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */\nclass ContractFactory {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The Contract deployment bytecode. Often called the initcode.\n     */\n    bytecode;\n    /**\n     *  The ContractRunner to deploy the Contract as.\n     */\n    runner;\n    /**\n     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n     *  optionally connected to %%runner%%.\n     *\n     *  The %%bytecode%% may be the ``bytecode`` property within the\n     *  standard Solidity JSON output.\n     */\n    constructor(abi, bytecode, runner) {\n        const iface = index_js_1.Interface.from(abi);\n        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n        if (bytecode instanceof Uint8Array) {\n            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n        }\n        else {\n            if (typeof (bytecode) === \"object\") {\n                bytecode = bytecode.object;\n            }\n            if (!bytecode.startsWith(\"0x\")) {\n                bytecode = \"0x\" + bytecode;\n            }\n            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n        }\n        (0, index_js_3.defineProperties)(this, {\n            bytecode, interface: iface, runner: (runner || null)\n        });\n    }\n    attach(target) {\n        return new contract_js_1.BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Resolves to the transaction to deploy the contract, passing %%args%%\n     *  into the constructor.\n     */\n    async getDeployTransaction(...args) {\n        let overrides = {};\n        const fragment = this.interface.deploy;\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await (0, contract_js_1.copyOverrides)(args.pop());\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"incorrect number of arguments to constructor\");\n        }\n        const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);\n        const data = (0, index_js_3.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);\n        return Object.assign({}, overrides, { data });\n    }\n    /**\n     *  Resolves to the Contract deployed by passing %%args%% into the\n     *  constructor.\n     *\n     *  This will resovle to the Contract before it has been deployed to the\n     *  network, so the [[BaseContract-waitForDeployment]] should be used before\n     *  sending any transactions to it.\n     */\n    async deploy(...args) {\n        const tx = await this.getDeployTransaction(...args);\n        (0, index_js_3.assert)(this.runner && typeof (this.runner.sendTransaction) === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const sentTx = await this.runner.sendTransaction(tx);\n        const address = (0, index_js_2.getCreateAddress)(sentTx);\n        return new contract_js_1.BaseContract(address, this.interface, this.runner, sentTx);\n    }\n    /**\n     *  Return a new **ContractFactory** with the same ABI and bytecode,\n     *  but connected to %%runner%%.\n     */\n    connect(runner) {\n        return new ContractFactory(this.interface, this.bytecode, runner);\n    }\n    /**\n     *  Create a new **ContractFactory** from the standard Solidity JSON output.\n     */\n    static fromSolidity(output, runner) {\n        (0, index_js_3.assertArgument)(output != null, \"bad compiler output\", \"output\", output);\n        if (typeof (output) === \"string\") {\n            output = JSON.parse(output);\n        }\n        const abi = output.abi;\n        let bytecode = \"\";\n        if (output.bytecode) {\n            bytecode = output.bytecode;\n        }\n        else if (output.evm && output.evm.bytecode) {\n            bytecode = output.evm.bytecode;\n        }\n        return new this(abi, bytecode, runner);\n    }\n}\nexports.ContractFactory = ContractFactory;\n//# sourceMappingURL=factory.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}