{"ast":null,"code":"\"use strict\";\n\n/**\n *  About bytes32 strings...\n *\n *  @_docloc: api/utils:Bytes32 Strings\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeBytes32String = exports.encodeBytes32String = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\n/**\n *  Encodes %%text%% as a Bytes32 string.\n */\nfunction encodeBytes32String(text) {\n  // Get the bytes\n  const bytes = (0, index_js_1.toUtf8Bytes)(text);\n  // Check we have room for null-termination\n  if (bytes.length > 31) {\n    throw new Error(\"bytes32 string must be less than 32 bytes\");\n  }\n  // Zero-pad (implicitly null-terminates)\n  return (0, index_js_1.zeroPadBytes)(bytes, 32);\n}\nexports.encodeBytes32String = encodeBytes32String;\n/**\n *  Encodes the Bytes32-encoded %%bytes%% into a string.\n */\nfunction decodeBytes32String(_bytes) {\n  const data = (0, index_js_1.getBytes)(_bytes, \"bytes\");\n  // Must be 32 bytes with a null-termination\n  if (data.length !== 32) {\n    throw new Error(\"invalid bytes32 - not 32 bytes long\");\n  }\n  if (data[31] !== 0) {\n    throw new Error(\"invalid bytes32 string - no null terminator\");\n  }\n  // Find the null termination\n  let length = 31;\n  while (data[length - 1] === 0) {\n    length--;\n  }\n  // Determine the string value\n  return (0, index_js_1.toUtf8String)(data.slice(0, length));\n}\nexports.decodeBytes32String = decodeBytes32String;","map":{"version":3,"sources":["../../src.ts/abi/bytes32.ts"],"names":[],"mappings":";;AAAA;;;;AAIG;;;;;AAEH,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAMA;;AAEG;AACH,SAAgB,mBAAmB,CAAC,IAAY,EAAA;EAE5C;EACA,MAAM,KAAK,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,WAAW,EAAC,IAAI,CAAC;EAE/B;EACA,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,EAAE;IAAE,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC;EAAG;EAExF;EACA,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,YAAY,EAAC,KAAK,EAAE,EAAE,CAAC;AAClC;AAVA,OAAA,CAAA,mBAAA,GAAA,mBAAA;AAYA;;AAEG;AACH,SAAgB,mBAAmB,CAAC,MAAiB,EAAA;EACjD,MAAM,IAAI,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,QAAQ,EAAC,MAAM,EAAE,OAAO,CAAC;EAEtC;EACA,IAAI,IAAI,CAAC,MAAM,KAAK,EAAE,EAAE;IAAE,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC;EAAG;EACnF,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE;IAAE,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC;EAAG;EAEvF;EACA,IAAI,MAAM,GAAG,EAAE;EACf,OAAO,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;IAAE,MAAM,EAAE;EAAG;EAE5C;EACA,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,YAAY,EAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;AAC9C;AAbA,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n *  About bytes32 strings...\n *\n *  @_docloc: api/utils:Bytes32 Strings\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeBytes32String = exports.encodeBytes32String = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\n/**\n *  Encodes %%text%% as a Bytes32 string.\n */\nfunction encodeBytes32String(text) {\n    // Get the bytes\n    const bytes = (0, index_js_1.toUtf8Bytes)(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error(\"bytes32 string must be less than 32 bytes\");\n    }\n    // Zero-pad (implicitly null-terminates)\n    return (0, index_js_1.zeroPadBytes)(bytes, 32);\n}\nexports.encodeBytes32String = encodeBytes32String;\n/**\n *  Encodes the Bytes32-encoded %%bytes%% into a string.\n */\nfunction decodeBytes32String(_bytes) {\n    const data = (0, index_js_1.getBytes)(_bytes, \"bytes\");\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error(\"invalid bytes32 - not 32 bytes long\");\n    }\n    if (data[31] !== 0) {\n        throw new Error(\"invalid bytes32 string - no null terminator\");\n    }\n    // Find the null termination\n    let length = 31;\n    while (data[length - 1] === 0) {\n        length--;\n    }\n    // Determine the string value\n    return (0, index_js_1.toUtf8String)(data.slice(0, length));\n}\nexports.decodeBytes32String = decodeBytes32String;\n//# sourceMappingURL=bytes32.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}