{"ast":null,"code":"\"use strict\";\n\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeBase58 = exports.encodeBase58 = void 0;\nconst data_js_1 = require(\"./data.js\");\nconst errors_js_1 = require(\"./errors.js\");\nconst maths_js_1 = require(\"./maths.js\");\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n  if (Lookup == null) {\n    Lookup = {};\n    for (let i = 0; i < Alphabet.length; i++) {\n      Lookup[Alphabet[i]] = BigInt(i);\n    }\n  }\n  const result = Lookup[letter];\n  (0, errors_js_1.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n  return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */\nfunction encodeBase58(_value) {\n  let value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value));\n  let result = \"\";\n  while (value) {\n    result = Alphabet[Number(value % BN_58)] + result;\n    value /= BN_58;\n  }\n  return result;\n}\nexports.encodeBase58 = encodeBase58;\n/**\n *  Decode the Base58-encoded %%value%%.\n */\nfunction decodeBase58(value) {\n  let result = BN_0;\n  for (let i = 0; i < value.length; i++) {\n    result *= BN_58;\n    result += getAlpha(value[i]);\n  }\n  return result;\n}\nexports.decodeBase58 = decodeBase58;","map":{"version":3,"sources":["../../src.ts/utils/base58.ts"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;AAYG;;;;;AAEH,MAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAKA,MAAM,QAAQ,GAAG,4DAA4D;AAC7E,IAAI,MAAM,GAAkC,IAAI;AAEhD,SAAS,QAAQ,CAAC,MAAc,EAAA;EAC5B,IAAI,MAAM,IAAI,IAAI,EAAE;IAChB,MAAM,GAAG,CAAA,CAAG;IACZ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MACtC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC;IAClC;EACJ;EACD,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;EAC7B,CAAA,CAAA,EAAA,WAAA,CAAA,cAAc,EAAC,MAAM,IAAI,IAAI,EAAE,sBAAsB,EAAE,QAAQ,EAAE,MAAM,CAAC;EACxE,OAAO,MAAM;AACjB;AAGA,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC;AACtB,MAAM,KAAK,GAAG,MAAM,CAAC,EAAE,CAAC;AAExB;;AAEG;AACH,SAAgB,YAAY,CAAC,MAAiB,EAAA;EAC1C,IAAI,KAAK,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,QAAQ,EAAC,CAAA,CAAA,EAAA,SAAA,CAAA,QAAQ,EAAC,MAAM,CAAC,CAAC;EACtC,IAAI,MAAM,GAAG,EAAE;EACf,OAAO,KAAK,EAAE;IACV,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,GAAG,MAAM;IACjD,KAAK,IAAI,KAAK;EACjB;EACD,OAAO,MAAM;AACjB;AARA,OAAA,CAAA,YAAA,GAAA,YAAA;AAUA;;AAEG;AACH,SAAgB,YAAY,CAAC,KAAa,EAAA;EACtC,IAAI,MAAM,GAAG,IAAI;EACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACnC,MAAM,IAAI,KAAK;IACf,MAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EAC/B;EACD,OAAO,MAAM;AACjB;AAPA,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeBase58 = exports.encodeBase58 = void 0;\nconst data_js_1 = require(\"./data.js\");\nconst errors_js_1 = require(\"./errors.js\");\nconst maths_js_1 = require(\"./maths.js\");\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for (let i = 0; i < Alphabet.length; i++) {\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0, errors_js_1.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */\nfunction encodeBase58(_value) {\n    let value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value));\n    let result = \"\";\n    while (value) {\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    return result;\n}\nexports.encodeBase58 = encodeBase58;\n/**\n *  Decode the Base58-encoded %%value%%.\n */\nfunction decodeBase58(value) {\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n}\nexports.decodeBase58 = decodeBase58;\n//# sourceMappingURL=base58.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}