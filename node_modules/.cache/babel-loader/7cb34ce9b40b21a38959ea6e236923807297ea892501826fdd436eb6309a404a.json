{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/esnext.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/esnext.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/esnext.typed-array.with.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.getNumber = exports.toBigInt = exports.getUint = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = void 0;\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nconst data_js_1 = require(\"./data.js\");\nconst errors_js_1 = require(\"./errors.js\");\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nfunction fromTwos(_value, _width) {\n  const value = getUint(_value, \"value\");\n  const width = BigInt(getNumber(_width, \"width\"));\n  (0, errors_js_1.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n    operation: \"fromTwos\",\n    fault: \"overflow\",\n    value: _value\n  });\n  // Top bit set; treat as a negative value\n  if (value >> width - BN_1) {\n    const mask = (BN_1 << width) - BN_1;\n    return -((~value & mask) + BN_1);\n  }\n  return value;\n}\nexports.fromTwos = fromTwos;\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nfunction toTwos(_value, _width) {\n  let value = getBigInt(_value, \"value\");\n  const width = BigInt(getNumber(_width, \"width\"));\n  const limit = BN_1 << width - BN_1;\n  if (value < BN_0) {\n    value = -value;\n    (0, errors_js_1.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n    const mask = (BN_1 << width) - BN_1;\n    return (~value & mask) + BN_1;\n  } else {\n    (0, errors_js_1.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n  }\n  return value;\n}\nexports.toTwos = toTwos;\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nfunction mask(_value, _bits) {\n  const value = getUint(_value, \"value\");\n  const bits = BigInt(getNumber(_bits, \"bits\"));\n  return value & (BN_1 << bits) - BN_1;\n}\nexports.mask = mask;\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getBigInt(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      return value;\n    case \"number\":\n      (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return BigInt(value);\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n        if (value[0] === \"-\" && value[1] !== \"-\") {\n          return -BigInt(value.substring(1));\n        }\n        return BigInt(value);\n      } catch (e) {\n        (0, errors_js_1.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n      }\n  }\n  (0, errors_js_1.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\nexports.getBigInt = getBigInt;\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nfunction getUint(value, name) {\n  const result = getBigInt(value, name);\n  (0, errors_js_1.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n    fault: \"overflow\",\n    operation: \"getUint\",\n    value\n  });\n  return result;\n}\nexports.getUint = getUint;\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nfunction toBigInt(value) {\n  if (value instanceof Uint8Array) {\n    let result = \"0x0\";\n    for (const v of value) {\n      result += Nibbles[v >> 4];\n      result += Nibbles[v & 0x0f];\n    }\n    return BigInt(result);\n  }\n  return getBigInt(value);\n}\nexports.toBigInt = toBigInt;\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getNumber(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return Number(value);\n    case \"number\":\n      (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return value;\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n        return getNumber(BigInt(value), name);\n      } catch (e) {\n        (0, errors_js_1.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n      }\n  }\n  (0, errors_js_1.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\nexports.getNumber = getNumber;\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nfunction toNumber(value) {\n  return getNumber(toBigInt(value));\n}\nexports.toNumber = toNumber;\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nfunction toBeHex(_value, _width) {\n  const value = getUint(_value, \"value\");\n  let result = value.toString(16);\n  if (_width == null) {\n    // Ensure the value is of even length\n    if (result.length % 2) {\n      result = \"0\" + result;\n    }\n  } else {\n    const width = getNumber(_width, \"width\");\n    (0, errors_js_1.assert)(width * 2 >= result.length, `value exceeds width (${width} bits)`, \"NUMERIC_FAULT\", {\n      operation: \"toBeHex\",\n      fault: \"overflow\",\n      value: _value\n    });\n    // Pad the value to the required width\n    while (result.length < width * 2) {\n      result = \"0\" + result;\n    }\n  }\n  return \"0x\" + result;\n}\nexports.toBeHex = toBeHex;\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nfunction toBeArray(_value) {\n  const value = getUint(_value, \"value\");\n  if (value === BN_0) {\n    return new Uint8Array([]);\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2) {\n    hex = \"0\" + hex;\n  }\n  const result = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < result.length; i++) {\n    const offset = i * 2;\n    result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n  }\n  return result;\n}\nexports.toBeArray = toBeArray;\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nfunction toQuantity(value) {\n  let result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n  while (result.startsWith(\"0\")) {\n    result = result.substring(1);\n  }\n  if (result === \"\") {\n    result = \"0\";\n  }\n  return \"0x\" + result;\n}\nexports.toQuantity = toQuantity;","map":{"version":3,"sources":["../../src.ts/utils/maths.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.getNumber = exports.toBigInt = exports.getUint = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = void 0;\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nconst data_js_1 = require(\"./data.js\");\nconst errors_js_1 = require(\"./errors.js\");\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nfunction fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0, errors_js_1.assert)((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n    return value;\n}\nexports.fromTwos = fromTwos;\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nfunction toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = (BN_1 << (width - BN_1));\n    if (value < BN_0) {\n        value = -value;\n        (0, errors_js_1.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    }\n    else {\n        (0, errors_js_1.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n    return value;\n}\nexports.toTwos = toTwos;\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nfunction mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\nexports.mask = mask;\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getBigInt(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            }\n            catch (e) {\n                (0, errors_js_1.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0, errors_js_1.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\nexports.getBigInt = getBigInt;\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nfunction getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0, errors_js_1.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\nexports.getUint = getUint;\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nfunction toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\nexports.toBigInt = toBigInt;\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nfunction getNumber(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\":\n            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            }\n            catch (e) {\n                (0, errors_js_1.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0, errors_js_1.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\nexports.getNumber = getNumber;\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nfunction toNumber(value) {\n    return getNumber(toBigInt(value));\n}\nexports.toNumber = toNumber;\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nfunction toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    }\n    else {\n        const width = getNumber(_width, \"width\");\n        (0, errors_js_1.assert)(width * 2 >= result.length, `value exceeds width (${width} bits)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while (result.length < (width * 2)) {\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\nexports.toBeHex = toBeHex;\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nfunction toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\nexports.toBeArray = toBeArray;\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nfunction toQuantity(value) {\n    let result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) {\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n}\nexports.toQuantity = toQuantity;\n//# sourceMappingURL=maths.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}