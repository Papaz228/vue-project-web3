{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nrequire(\"core-js/modules/esnext.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/esnext.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/esnext.typed-array.with.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Mnemonic = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../utils/index.js\");\nconst lang_en_js_1 = require(\"../wordlists/lang-en.js\");\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1 & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  (0, index_js_2.assertNormalize)(\"NFKD\");\n  if (wordlist == null) {\n    wordlist = lang_en_js_1.LangEn.wordlist();\n  }\n  const words = wordlist.split(mnemonic);\n  (0, index_js_2.assertArgument)(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n  const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n  let offset = 0;\n  for (let i = 0; i < words.length; i++) {\n    let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n    (0, index_js_2.assertArgument)(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\n    for (let bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n      offset++;\n    }\n  }\n  const entropyBits = 32 * words.length / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n  (0, index_js_2.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n  return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n  (0, index_js_2.assertArgument)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n  if (wordlist == null) {\n    wordlist = lang_en_js_1.LangEn.wordlist();\n  }\n  const indices = [0];\n  let remainingBits = 11;\n  for (let i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8;\n      // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;\n      // Start the next word\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  }\n  // Compute the checksum bits\n  const checksumBits = entropy.length / 4;\n  const checksum = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n  // Shift the checksum into the word indices\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n  return wordlist.join(indices.map(index => wordlist.getWord(index)));\n}\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nclass Mnemonic {\n  /**\n   *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n   *\n   *  Use the [[wordlist]] ``split`` method to get the individual words.\n   */\n\n  /**\n   *  The password used for this mnemonic. If no password is used this\n   *  is the empty string (i.e. ``\"\"``) as per the specification.\n   */\n\n  /**\n   *  The wordlist for this mnemonic.\n   */\n\n  /**\n   *  The underlying entropy which the mnemonic encodes.\n   */\n\n  /**\n   *  @private\n   */\n  constructor(guard, entropy, phrase, password, wordlist) {\n    _defineProperty(this, \"phrase\", void 0);\n    _defineProperty(this, \"password\", void 0);\n    _defineProperty(this, \"wordlist\", void 0);\n    _defineProperty(this, \"entropy\", void 0);\n    if (password == null) {\n      password = \"\";\n    }\n    if (wordlist == null) {\n      wordlist = lang_en_js_1.LangEn.wordlist();\n    }\n    (0, index_js_2.assertPrivate)(guard, _guard, \"Mnemonic\");\n    (0, index_js_2.defineProperties)(this, {\n      phrase,\n      password,\n      wordlist,\n      entropy\n    });\n  }\n  /**\n   *  Returns the seed for the mnemonic.\n   */\n  computeSeed() {\n    const salt = (0, index_js_2.toUtf8Bytes)(\"mnemonic\" + this.password, \"NFKD\");\n    return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n  }\n  /**\n   *  Creates a new Mnemonic for the %%phrase%%.\n   *\n   *  The default %%password%% is the empty string and the default\n   *  wordlist is the [English wordlists](LangEn).\n   */\n  static fromPhrase(phrase, password, wordlist) {\n    // Normalize the case and space; throws if invalid\n    const entropy = mnemonicToEntropy(phrase, wordlist);\n    phrase = entropyToMnemonic((0, index_js_2.getBytes)(entropy), wordlist);\n    return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n  }\n  /**\n   *  Create a new **Mnemonic** from the %%entropy%%.\n   *\n   *  The default %%password%% is the empty string and the default\n   *  wordlist is the [English wordlists](LangEn).\n   */\n  static fromEntropy(_entropy, password, wordlist) {\n    const entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n    const phrase = entropyToMnemonic(entropy, wordlist);\n    return new Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist);\n  }\n  /**\n   *  Returns the phrase for %%mnemonic%%.\n   */\n  static entropyToPhrase(_entropy, wordlist) {\n    const entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n    return entropyToMnemonic(entropy, wordlist);\n  }\n  /**\n   *  Returns the entropy for %%phrase%%.\n   */\n  static phraseToEntropy(phrase, wordlist) {\n    return mnemonicToEntropy(phrase, wordlist);\n  }\n  /**\n   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n   *\n   *  This checks all the provided words belong to the %%wordlist%%,\n   *  that the length is valid and the checksum is correct.\n   */\n  static isValidMnemonic(phrase, wordlist) {\n    try {\n      mnemonicToEntropy(phrase, wordlist);\n      return true;\n    } catch (error) {}\n    return false;\n  }\n}\nexports.Mnemonic = Mnemonic;","map":{"version":3,"sources":["../../src.ts/wallet/mnemonic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Mnemonic = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../utils/index.js\");\nconst lang_en_js_1 = require(\"../wordlists/lang-en.js\");\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n    return ((1 << bits) - 1) << (8 - bits) & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n    return ((1 << bits) - 1) & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    (0, index_js_2.assertNormalize)(\"NFKD\");\n    if (wordlist == null) {\n        wordlist = lang_en_js_1.LangEn.wordlist();\n    }\n    const words = wordlist.split(mnemonic);\n    (0, index_js_2.assertArgument)((words.length % 3) === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        (0, index_js_2.assertArgument)(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n    const entropyBits = 32 * words.length / 3;\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n    const checksum = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n    (0, index_js_2.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n    return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    (0, index_js_2.assertArgument)((entropy.length % 4) === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n    if (wordlist == null) {\n        wordlist = lang_en_js_1.LangEn.wordlist();\n    }\n    const indices = [0];\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n            remainingBits -= 8;\n            // This byte will complete an 11-bit index\n        }\n        else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n            remainingBits += 3;\n        }\n    }\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n    return wordlist.join(indices.map((index) => wordlist.getWord(index)));\n}\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nclass Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    phrase;\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     *  is the empty string (i.e. ``\"\"``) as per the specification.\n     */\n    password;\n    /**\n     *  The wordlist for this mnemonic.\n     */\n    wordlist;\n    /**\n     *  The underlying entropy which the mnemonic encodes.\n     */\n    entropy;\n    /**\n     *  @private\n     */\n    constructor(guard, entropy, phrase, password, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (wordlist == null) {\n            wordlist = lang_en_js_1.LangEn.wordlist();\n        }\n        (0, index_js_2.assertPrivate)(guard, _guard, \"Mnemonic\");\n        (0, index_js_2.defineProperties)(this, { phrase, password, wordlist, entropy });\n    }\n    /**\n     *  Returns the seed for the mnemonic.\n     */\n    computeSeed() {\n        const salt = (0, index_js_2.toUtf8Bytes)(\"mnemonic\" + this.password, \"NFKD\");\n        return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n    }\n    /**\n     *  Creates a new Mnemonic for the %%phrase%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromPhrase(phrase, password, wordlist) {\n        // Normalize the case and space; throws if invalid\n        const entropy = mnemonicToEntropy(phrase, wordlist);\n        phrase = entropyToMnemonic((0, index_js_2.getBytes)(entropy), wordlist);\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n    }\n    /**\n     *  Create a new **Mnemonic** from the %%entropy%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromEntropy(_entropy, password, wordlist) {\n        const entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n        const phrase = entropyToMnemonic(entropy, wordlist);\n        return new Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist);\n    }\n    /**\n     *  Returns the phrase for %%mnemonic%%.\n     */\n    static entropyToPhrase(_entropy, wordlist) {\n        const entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n        return entropyToMnemonic(entropy, wordlist);\n    }\n    /**\n     *  Returns the entropy for %%phrase%%.\n     */\n    static phraseToEntropy(phrase, wordlist) {\n        return mnemonicToEntropy(phrase, wordlist);\n    }\n    /**\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n     *\n     *  This checks all the provided words belong to the %%wordlist%%,\n     *  that the length is valid and the checksum is correct.\n     */\n    static isValidMnemonic(phrase, wordlist) {\n        try {\n            mnemonicToEntropy(phrase, wordlist);\n            return true;\n        }\n        catch (error) { }\n        return false;\n    }\n}\nexports.Mnemonic = Mnemonic;\n//# sourceMappingURL=mnemonic.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}