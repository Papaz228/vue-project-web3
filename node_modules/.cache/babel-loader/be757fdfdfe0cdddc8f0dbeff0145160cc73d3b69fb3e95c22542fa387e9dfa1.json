{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCreate2Address = exports.getCreateAddress = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../utils/index.js\");\nconst address_js_1 = require(\"./address.js\");\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */\nfunction getCreateAddress(tx) {\n  const from = (0, address_js_1.getAddress)(tx.from);\n  const nonce = (0, index_js_2.getBigInt)(tx.nonce, \"tx.nonce\");\n  let nonceHex = nonce.toString(16);\n  if (nonceHex === \"0\") {\n    nonceHex = \"0x\";\n  } else if (nonceHex.length % 2) {\n    nonceHex = \"0x0\" + nonceHex;\n  } else {\n    nonceHex = \"0x\" + nonceHex;\n  }\n  return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.encodeRlp)([from, nonceHex])), 12));\n}\nexports.getCreateAddress = getCreateAddress;\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */\nfunction getCreate2Address(_from, _salt, _initCodeHash) {\n  const from = (0, address_js_1.getAddress)(_from);\n  const salt = (0, index_js_2.getBytes)(_salt, \"salt\");\n  const initCodeHash = (0, index_js_2.getBytes)(_initCodeHash, \"initCodeHash\");\n  (0, index_js_2.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n  (0, index_js_2.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n  return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)([\"0xff\", from, salt, initCodeHash])), 12));\n}\nexports.getCreate2Address = getCreate2Address;","map":{"version":3,"sources":["../../src.ts/address/contract-address.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAIA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAKA;AAEA;;;;;;;;;;;;;;;;;AAiBG;AACH,SAAgB,gBAAgB,CAAC,EAAyC,EAAA;EACtE,MAAM,IAAI,GAAG,CAAA,CAAA,EAAA,YAAA,CAAA,UAAU,EAAC,EAAE,CAAC,IAAI,CAAC;EAChC,MAAM,KAAK,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,SAAS,EAAC,EAAE,CAAC,KAAK,EAAE,UAAU,CAAC;EAE7C,IAAI,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC;EACjC,IAAI,QAAQ,KAAK,GAAG,EAAE;IAClB,QAAQ,GAAG,IAAI;GAClB,MAAM,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;IAC5B,QAAQ,GAAG,KAAK,GAAG,QAAQ;GAC9B,MAAM;IACH,QAAQ,GAAG,IAAI,GAAG,QAAQ;EAC7B;EAED,OAAO,CAAA,CAAA,EAAA,YAAA,CAAA,UAAU,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,SAAS,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,SAAS,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,SAAS,EAAC,CAAE,IAAI,EAAE,QAAQ,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC9E;AAdA,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAgBA;;;;;;;;;;;;;;;;;;;;;;AAsBG;AACH,SAAgB,iBAAiB,CAAC,KAAa,EAAE,KAAgB,EAAE,aAAwB,EAAA;EACvF,MAAM,IAAI,GAAG,CAAA,CAAA,EAAA,YAAA,CAAA,UAAU,EAAC,KAAK,CAAC;EAC9B,MAAM,IAAI,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,QAAQ,EAAC,KAAK,EAAE,MAAM,CAAC;EACpC,MAAM,YAAY,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,QAAQ,EAAC,aAAa,EAAE,cAAc,CAAC;EAE5D,CAAA,CAAA,EAAA,UAAA,CAAA,cAAc,EAAC,IAAI,CAAC,MAAM,KAAK,EAAE,EAAE,uBAAuB,EAAE,MAAM,EAAE,KAAK,CAAC;EAE1E,CAAA,CAAA,EAAA,UAAA,CAAA,cAAc,EAAC,YAAY,CAAC,MAAM,KAAK,EAAE,EAAE,+BAA+B,EAAE,cAAc,EAAE,aAAa,CAAC;EAE1G,OAAO,CAAA,CAAA,EAAA,YAAA,CAAA,UAAU,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,SAAS,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,SAAS,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,MAAM,EAAC,CAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC7F;AAVA,OAAA,CAAA,iBAAA,GAAA,iBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCreate2Address = exports.getCreateAddress = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../utils/index.js\");\nconst address_js_1 = require(\"./address.js\");\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */\nfunction getCreateAddress(tx) {\n    const from = (0, address_js_1.getAddress)(tx.from);\n    const nonce = (0, index_js_2.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    }\n    else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    }\n    else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.encodeRlp)([from, nonceHex])), 12));\n}\nexports.getCreateAddress = getCreateAddress;\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */\nfunction getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0, address_js_1.getAddress)(_from);\n    const salt = (0, index_js_2.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0, index_js_2.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0, index_js_2.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0, index_js_2.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)([\"0xff\", from, salt, initCodeHash])), 12));\n}\nexports.getCreate2Address = getCreate2Address;\n//# sourceMappingURL=contract-address.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}