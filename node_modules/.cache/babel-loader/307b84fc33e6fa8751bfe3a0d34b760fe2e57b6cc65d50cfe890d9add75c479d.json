{"ast":null,"code":"\"use strict\";\n\nvar _classPrivateMethodInitSpec = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateMethodGet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _defineProperty = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldGet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nrequire(\"core-js/modules/esnext.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/esnext.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/esnext.typed-array.with.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;\nconst index_js_1 = require(\"../../utils/index.js\");\n/**\n * @_ignore:\n */\nexports.WordSize = 32;\nconst Padding = new Uint8Array(exports.WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nfunction throwError(name, error) {\n  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n  wrapped.error = error;\n  throw wrapped;\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nvar _names = /*#__PURE__*/new WeakMap();\nclass Result extends Array {\n  /**\n   *  @private\n   */\n  constructor(...args) {\n    // To properly sub-class Array so the other built-in\n    // functions work, the constructor has to behave fairly\n    // well. So, in the event we are created via fromItems()\n    // we build the read-only Result object we want, but on\n    // any other input, we use the default constructor\n    // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n    const guard = args[0];\n    let items = args[1];\n    let names = (args[2] || []).slice();\n    let wrap = true;\n    if (guard !== _guard) {\n      items = args;\n      names = [];\n      wrap = false;\n    }\n    // Can't just pass in ...items since an array of length 1\n    // is a special case in the super.\n    super(items.length);\n    _classPrivateFieldInitSpec(this, _names, {\n      writable: true,\n      value: void 0\n    });\n    items.forEach((item, index) => {\n      this[index] = item;\n    });\n    // Find all unique keys\n    const nameCounts = names.reduce((accum, name) => {\n      if (typeof name === \"string\") {\n        accum.set(name, (accum.get(name) || 0) + 1);\n      }\n      return accum;\n    }, new Map());\n    // Remove any key thats not unique\n    _classPrivateFieldSet(this, _names, Object.freeze(items.map((item, index) => {\n      const name = names[index];\n      if (name != null && nameCounts.get(name) === 1) {\n        return name;\n      }\n      return null;\n    })));\n    if (!wrap) {\n      return;\n    }\n    // A wrapped Result is immutable\n    Object.freeze(this);\n    // Proxy indices and names so we can trap deferred errors\n    return new Proxy(this, {\n      get: (target, prop, receiver) => {\n        if (typeof prop === \"string\") {\n          // Index accessor\n          if (prop.match(/^[0-9]+$/)) {\n            const index = (0, index_js_1.getNumber)(prop, \"%index\");\n            if (index < 0 || index >= this.length) {\n              throw new RangeError(\"out of result range\");\n            }\n            const item = target[index];\n            if (item instanceof Error) {\n              throwError(`index ${index}`, item);\n            }\n            return item;\n          }\n          // Pass important checks (like `then` for Promise) through\n          if (passProperties.indexOf(prop) >= 0) {\n            return Reflect.get(target, prop, receiver);\n          }\n          const value = target[prop];\n          if (value instanceof Function) {\n            // Make sure functions work with private variables\n            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n            return function (...args) {\n              return value.apply(this === receiver ? target : this, args);\n            };\n          } else if (!(prop in target)) {\n            // Possible name accessor\n            return target.getValue.apply(this === receiver ? target : this, [prop]);\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n  /**\n   *  Returns the Result as a normal Array.\n   *\n   *  This will throw if there are any outstanding deferred\n   *  errors.\n   */\n  toArray() {\n    const result = [];\n    this.forEach((item, index) => {\n      if (item instanceof Error) {\n        throwError(`index ${index}`, item);\n      }\n      result.push(item);\n    });\n    return result;\n  }\n  /**\n   *  Returns the Result as an Object with each name-value pair.\n   *\n   *  This will throw if any value is unnamed, or if there are\n   *  any outstanding deferred errors.\n   */\n  toObject() {\n    return _classPrivateFieldGet(this, _names).reduce((accum, name, index) => {\n      (0, index_js_1.assert)(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"toObject()\"\n      });\n      // Add values for names that don't conflict\n      if (!(name in accum)) {\n        accum[name] = this.getValue(name);\n      }\n      return accum;\n    }, {});\n  }\n  /**\n   *  @_ignore\n   */\n  slice(start, end) {\n    if (start == null) {\n      start = 0;\n    }\n    if (start < 0) {\n      start += this.length;\n      if (start < 0) {\n        start = 0;\n      }\n    }\n    if (end == null) {\n      end = this.length;\n    }\n    if (end < 0) {\n      end += this.length;\n      if (end < 0) {\n        end = 0;\n      }\n    }\n    if (end > this.length) {\n      end = this.length;\n    }\n    const result = [],\n      names = [];\n    for (let i = start; i < end; i++) {\n      result.push(this[i]);\n      names.push(_classPrivateFieldGet(this, _names)[i]);\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  filter(callback, thisArg) {\n    const result = [],\n      names = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(`index ${i}`, item);\n      }\n      if (callback.call(thisArg, item, i, this)) {\n        result.push(item);\n        names.push(_classPrivateFieldGet(this, _names)[i]);\n      }\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  map(callback, thisArg) {\n    const result = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(`index ${i}`, item);\n      }\n      result.push(callback.call(thisArg, item, i, this));\n    }\n    return result;\n  }\n  /**\n   *  Returns the value for %%name%%.\n   *\n   *  Since it is possible to have a key whose name conflicts with\n   *  a method on a [[Result]] or its superclass Array, or any\n   *  JavaScript keyword, this ensures all named values are still\n   *  accessible by name.\n   */\n  getValue(name) {\n    const index = _classPrivateFieldGet(this, _names).indexOf(name);\n    if (index === -1) {\n      return undefined;\n    }\n    const value = this[index];\n    if (value instanceof Error) {\n      throwError(`property ${JSON.stringify(name)}`, value.error);\n    }\n    return value;\n  }\n  /**\n   *  Creates a new [[Result]] for %%items%% with each entry\n   *  also accessible by its corresponding name in %%keys%%.\n   */\n  static fromItems(items, keys) {\n    return new Result(_guard, items, keys);\n  }\n}\nexports.Result = Result;\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nfunction checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nexports.checkResultErrors = checkResultErrors;\nfunction getValue(value) {\n  let bytes = (0, index_js_1.toBeArray)(value);\n  (0, index_js_1.assert)(bytes.length <= exports.WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n    buffer: bytes,\n    length: exports.WordSize,\n    offset: bytes.length\n  });\n  if (bytes.length !== exports.WordSize) {\n    bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));\n  }\n  return bytes;\n}\n/**\n *  @_ignore\n */\nclass Coder {\n  // The coder name:\n  //   - address, uint256, tuple, array, etc.\n\n  // The fully expanded type, including composite types:\n  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n\n  // The localName bound in the signature, in this example it is \"baz\":\n  //   - tuple(address foo, uint bar) baz\n\n  // Whether this type is dynamic:\n  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n\n  constructor(name, type, localName, dynamic) {\n    _defineProperty(this, \"name\", void 0);\n    _defineProperty(this, \"type\", void 0);\n    _defineProperty(this, \"localName\", void 0);\n    _defineProperty(this, \"dynamic\", void 0);\n    (0, index_js_1.defineProperties)(this, {\n      name,\n      type,\n      localName,\n      dynamic\n    }, {\n      name: \"string\",\n      type: \"string\",\n      localName: \"string\",\n      dynamic: \"boolean\"\n    });\n  }\n  _throwError(message, value) {\n    (0, index_js_1.assertArgument)(false, message, this.localName, value);\n  }\n}\nexports.Coder = Coder;\n/**\n *  @_ignore\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _dataLength = /*#__PURE__*/new WeakMap();\nvar _writeData = /*#__PURE__*/new WeakSet();\nclass Writer {\n  // An array of WordSize lengthed objects to concatenation\n\n  constructor() {\n    _classPrivateMethodInitSpec(this, _writeData);\n    _classPrivateFieldInitSpec(this, _data, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _dataLength, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _data, []);\n    _classPrivateFieldSet(this, _dataLength, 0);\n  }\n  get data() {\n    return (0, index_js_1.concat)(_classPrivateFieldGet(this, _data));\n  }\n  get length() {\n    return _classPrivateFieldGet(this, _dataLength);\n  }\n  appendWriter(writer) {\n    return _classPrivateMethodGet(this, _writeData, _writeData2).call(this, (0, index_js_1.getBytesCopy)(writer.data));\n  }\n  // Arrayish item; pad on the right to *nearest* WordSize\n  writeBytes(value) {\n    let bytes = (0, index_js_1.getBytesCopy)(value);\n    const paddingOffset = bytes.length % exports.WordSize;\n    if (paddingOffset) {\n      bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));\n    }\n    return _classPrivateMethodGet(this, _writeData, _writeData2).call(this, bytes);\n  }\n  // Numeric item; pad on the left *to* WordSize\n  writeValue(value) {\n    return _classPrivateMethodGet(this, _writeData, _writeData2).call(this, getValue(value));\n  }\n  // Inserts a numeric place-holder, returning a callback that can\n  // be used to asjust the value later\n  writeUpdatableValue() {\n    const offset = _classPrivateFieldGet(this, _data).length;\n    _classPrivateFieldGet(this, _data).push(Padding);\n    _classPrivateFieldSet(this, _dataLength, _classPrivateFieldGet(this, _dataLength) + exports.WordSize);\n    return value => {\n      _classPrivateFieldGet(this, _data)[offset] = getValue(value);\n    };\n  }\n}\nfunction _writeData2(data) {\n  _classPrivateFieldGet(this, _data).push(data);\n  _classPrivateFieldSet(this, _dataLength, _classPrivateFieldGet(this, _dataLength) + data.length);\n  return data.length;\n}\nexports.Writer = Writer;\n/**\n *  @_ignore\n */\nvar _data2 = /*#__PURE__*/new WeakMap();\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _peekBytes = /*#__PURE__*/new WeakSet();\nclass Reader {\n  // Allows incomplete unpadded data to be read; otherwise an error\n  // is raised if attempting to overrun the buffer. This is required\n  // to deal with an old Solidity bug, in which event data for\n  // external (not public thoguh) was tightly packed.\n\n  constructor(data, allowLoose) {\n    _classPrivateMethodInitSpec(this, _peekBytes);\n    _defineProperty(this, \"allowLoose\", void 0);\n    _classPrivateFieldInitSpec(this, _data2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _offset, {\n      writable: true,\n      value: void 0\n    });\n    (0, index_js_1.defineProperties)(this, {\n      allowLoose: !!allowLoose\n    });\n    _classPrivateFieldSet(this, _data2, (0, index_js_1.getBytesCopy)(data));\n    _classPrivateFieldSet(this, _offset, 0);\n  }\n  get data() {\n    return (0, index_js_1.hexlify)(_classPrivateFieldGet(this, _data2));\n  }\n  get dataLength() {\n    return _classPrivateFieldGet(this, _data2).length;\n  }\n  get consumed() {\n    return _classPrivateFieldGet(this, _offset);\n  }\n  get bytes() {\n    return new Uint8Array(_classPrivateFieldGet(this, _data2));\n  }\n  // Create a sub-reader with the same underlying data, but offset\n  subReader(offset) {\n    return new Reader(_classPrivateFieldGet(this, _data2).slice(_classPrivateFieldGet(this, _offset) + offset), this.allowLoose);\n  }\n  // Read bytes\n  readBytes(length, loose) {\n    let bytes = _classPrivateMethodGet(this, _peekBytes, _peekBytes2).call(this, 0, length, !!loose);\n    _classPrivateFieldSet(this, _offset, _classPrivateFieldGet(this, _offset) + bytes.length);\n    // @TODO: Make sure the length..end bytes are all 0?\n    return bytes.slice(0, length);\n  }\n  // Read a numeric values\n  readValue() {\n    return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));\n  }\n  readIndex() {\n    return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));\n  }\n}\nfunction _peekBytes2(offset, length, loose) {\n  let alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;\n  if (_classPrivateFieldGet(this, _offset) + alignedLength > _classPrivateFieldGet(this, _data2).length) {\n    if (this.allowLoose && loose && _classPrivateFieldGet(this, _offset) + length <= _classPrivateFieldGet(this, _data2).length) {\n      alignedLength = length;\n    } else {\n      (0, index_js_1.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: (0, index_js_1.getBytesCopy)(_classPrivateFieldGet(this, _data2)),\n        length: _classPrivateFieldGet(this, _data2).length,\n        offset: _classPrivateFieldGet(this, _offset) + alignedLength\n      });\n    }\n  }\n  return _classPrivateFieldGet(this, _data2).slice(_classPrivateFieldGet(this, _offset), _classPrivateFieldGet(this, _offset) + alignedLength);\n}\nexports.Reader = Reader;","map":{"version":3,"sources":["../../../src.ts/abi/coders/abstract-coder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;\nconst index_js_1 = require(\"../../utils/index.js\");\n/**\n * @_ignore:\n */\nexports.WordSize = 32;\nconst Padding = new Uint8Array(exports.WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nclass Result extends Array {\n    #names;\n    /**\n     *  @private\n     */\n    constructor(...args) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof (name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, (new Map()));\n        // Remove any key thats not unique\n        this.#names = Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        }));\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0, index_js_1.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function (...args) {\n                            return value.apply((this === receiver) ? target : this, args);\n                        };\n                    }\n                    else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target : this, [prop]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n    /**\n     *  Returns the Result as a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray() {\n        const result = [];\n        this.forEach((item, index) => {\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject() {\n        return this.#names.reduce((accum, name, index) => {\n            (0, index_js_1.assert)(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            // Add values for names that don't conflict\n            if (!(name in accum)) {\n                accum[name] = this.getValue(name);\n            }\n            return accum;\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */\n    slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const result = [], names = [];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(this.#names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    filter(callback, thisArg) {\n        const result = [], names = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(this.#names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    map(callback, thisArg) {\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name) {\n        const index = this.#names.indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\nexports.Result = Result;\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nfunction checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexports.checkResultErrors = checkResultErrors;\nfunction getValue(value) {\n    let bytes = (0, index_js_1.toBeArray)(value);\n    (0, index_js_1.assert)(bytes.length <= exports.WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", { buffer: bytes, length: exports.WordSize, offset: bytes.length });\n    if (bytes.length !== exports.WordSize) {\n        bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */\nclass Coder {\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    name;\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    type;\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    localName;\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    dynamic;\n    constructor(name, type, localName, dynamic) {\n        (0, index_js_1.defineProperties)(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0, index_js_1.assertArgument)(false, message, this.localName, value);\n    }\n}\nexports.Coder = Coder;\n/**\n *  @_ignore\n */\nclass Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor() {\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0, index_js_1.concat)(this.#data);\n    }\n    get length() { return this.#dataLength; }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0, index_js_1.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0, index_js_1.getBytesCopy)(value);\n        const paddingOffset = bytes.length % exports.WordSize;\n        if (paddingOffset) {\n            bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += exports.WordSize;\n        return (value) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\nexports.Writer = Writer;\n/**\n *  @_ignore\n */\nclass Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    allowLoose;\n    #data;\n    #offset;\n    constructor(data, allowLoose) {\n        (0, index_js_1.defineProperties)(this, { allowLoose: !!allowLoose });\n        this.#data = (0, index_js_1.getBytesCopy)(data);\n        this.#offset = 0;\n    }\n    get data() { return (0, index_js_1.hexlify)(this.#data); }\n    get dataLength() { return this.#data.length; }\n    get consumed() { return this.#offset; }\n    get bytes() { return new Uint8Array(this.#data); }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            }\n            else {\n                (0, index_js_1.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0, index_js_1.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));\n    }\n    readIndex() {\n        return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));\n    }\n}\nexports.Reader = Reader;\n//# sourceMappingURL=abstract-coder.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}