{"ast":null,"code":"\"use strict\";\n\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\nrequire(\"core-js/modules/esnext.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/esnext.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/esnext.typed-array.with.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.makeError = exports.isCallException = exports.isError = void 0;\nconst _version_js_1 = require(\"../_version.js\");\nconst properties_js_1 = require(\"./properties.js\");\nfunction stringify(value) {\n  if (value == null) {\n    return \"null\";\n  }\n  if (Array.isArray(value)) {\n    return \"[ \" + value.map(stringify).join(\", \") + \" ]\";\n  }\n  if (value instanceof Uint8Array) {\n    const HEX = \"0123456789abcdef\";\n    let result = \"0x\";\n    for (let i = 0; i < value.length; i++) {\n      result += HEX[value[i] >> 4];\n      result += HEX[value[i] & 0xf];\n    }\n    return result;\n  }\n  if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n    return stringify(value.toJSON());\n  }\n  switch (typeof value) {\n    case \"boolean\":\n    case \"symbol\":\n      return value.toString();\n    case \"bigint\":\n      return BigInt(value).toString();\n    case \"number\":\n      return value.toString();\n    case \"string\":\n      return JSON.stringify(value);\n    case \"object\":\n      {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{ \" + keys.map(k => `${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n      }\n  }\n  return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript envornoments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nfunction isError(error, code) {\n  return error && error.code === code;\n}\nexports.isError = isError;\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nfunction isCallException(error) {\n  return isError(error, \"CALL_EXCEPTION\");\n}\nexports.isCallException = isCallException;\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additioanl properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depneding on %%code%%, additional\n *  required properties. The error message will also include the %%meeage%%,\n *  ethers version, %%code%% and all aditional properties, serialized.\n */\nfunction makeError(message, code, info) {\n  {\n    const details = [];\n    if (info) {\n      if (\"message\" in info || \"code\" in info || \"name\" in info) {\n        throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n      }\n      for (const key in info) {\n        const value = info[key];\n        //                try {\n        details.push(key + \"=\" + stringify(value));\n        //                } catch (error: any) {\n        //                console.log(\"MMM\", error.message);\n        //                    details.push(key + \"=[could not serialize object]\");\n        //                }\n      }\n    }\n\n    details.push(`code=${code}`);\n    details.push(`version=${_version_js_1.version}`);\n    if (details.length) {\n      message += \" (\" + details.join(\", \") + \")\";\n    }\n  }\n  let error;\n  switch (code) {\n    case \"INVALID_ARGUMENT\":\n      error = new TypeError(message);\n      break;\n    case \"NUMERIC_FAULT\":\n    case \"BUFFER_OVERRUN\":\n      error = new RangeError(message);\n      break;\n    default:\n      error = new Error(message);\n  }\n  (0, properties_js_1.defineProperties)(error, {\n    code\n  });\n  if (info) {\n    Object.assign(error, info);\n  }\n  return error;\n}\nexports.makeError = makeError;\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nfunction assert(check, message, code, info) {\n  if (!check) {\n    throw makeError(message, code, info);\n  }\n}\nexports.assert = assert;\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nfunction assertArgument(check, message, name, value) {\n  assert(check, message, \"INVALID_ARGUMENT\", {\n    argument: name,\n    value: value\n  });\n}\nexports.assertArgument = assertArgument;\nfunction assertArgumentCount(count, expectedCount, message) {\n  if (message == null) {\n    message = \"\";\n  }\n  if (message) {\n    message = \": \" + message;\n  }\n  assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n    count: count,\n    expectedCount: expectedCount\n  });\n  assert(count <= expectedCount, \"too many arguemnts\" + message, \"UNEXPECTED_ARGUMENT\", {\n    count: count,\n    expectedCount: expectedCount\n  });\n}\nexports.assertArgumentCount = assertArgumentCount;\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n  try {\n    // General test for normalize\n    /* c8 ignore start */\n    if (\"test\".normalize(form) !== \"test\") {\n      throw new Error(\"bad\");\n    }\n    ;\n    /* c8 ignore stop */\n    if (form === \"NFD\") {\n      const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n      const expected = String.fromCharCode(0x65, 0x0301);\n      /* c8 ignore start */\n      if (check !== expected) {\n        throw new Error(\"broken\");\n      }\n      /* c8 ignore stop */\n    }\n\n    accum.push(form);\n  } catch (error) {}\n  return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nfunction assertNormalize(form) {\n  assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"String.prototype.normalize\",\n    info: {\n      form\n    }\n  });\n}\nexports.assertNormalize = assertNormalize;\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nfunction assertPrivate(givenGuard, guard, className) {\n  if (className == null) {\n    className = \"\";\n  }\n  if (givenGuard !== guard) {\n    let method = className,\n      operation = \"new\";\n    if (className) {\n      method += \".\";\n      operation += \" \" + className;\n    }\n    assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n      operation\n    });\n  }\n}\nexports.assertPrivate = assertPrivate;","map":{"version":3,"sources":["../../src.ts/utils/errors.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.makeError = exports.isCallException = exports.isError = void 0;\nconst _version_js_1 = require(\"../_version.js\");\nconst properties_js_1 = require(\"./properties.js\");\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript envornoments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nfunction isError(error, code) {\n    return (error && error.code === code);\n}\nexports.isError = isError;\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nfunction isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\nexports.isCallException = isCallException;\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additioanl properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depneding on %%code%%, additional\n *  required properties. The error message will also include the %%meeage%%,\n *  ethers version, %%code%% and all aditional properties, serialized.\n */\nfunction makeError(message, code, info) {\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js_1.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0, properties_js_1.defineProperties)(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    return error;\n}\nexports.makeError = makeError;\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nfunction assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\nexports.assert = assert;\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nfunction assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nexports.assertArgument = assertArgument;\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguemnts\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nexports.assertArgumentCount = assertArgumentCount;\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nfunction assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\nexports.assertNormalize = assertNormalize;\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nfunction assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\nexports.assertPrivate = assertPrivate;\n//# sourceMappingURL=errors.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}