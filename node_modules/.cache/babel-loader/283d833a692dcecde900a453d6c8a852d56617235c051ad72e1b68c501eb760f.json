{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateFieldInitSpec = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldGet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;\nconst index_js_1 = require(\"../abi/index.js\");\nconst index_js_2 = require(\"../address/index.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = require(\"../providers/provider.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst wrappers_js_1 = require(\"./wrappers.js\");\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n  return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n  return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n  return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n  return value && typeof value.sendTransaction === \"function\";\n}\nvar _filter = /*#__PURE__*/new WeakMap();\nclass PreparedTopicFilter {\n  constructor(contract, fragment, args) {\n    _classPrivateFieldInitSpec(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"fragment\", void 0);\n    (0, index_js_3.defineProperties)(this, {\n      fragment\n    });\n    if (fragment.inputs.length < args.length) {\n      throw new Error(\"too many arguments\");\n    }\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(contract.runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    _classPrivateFieldSet(this, _filter, async function () {\n      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n        const arg = args[index];\n        if (arg == null) {\n          return null;\n        }\n        return param.walkAsync(args[index], (type, value) => {\n          if (type === \"address\") {\n            return (0, index_js_2.resolveAddress)(value, resolver);\n          }\n          return value;\n        });\n      }));\n      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n    }());\n  }\n  getTopicFilter() {\n    return _classPrivateFieldGet(this, _filter);\n  }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n  if (value == null) {\n    return null;\n  }\n  if (typeof value[feature] === \"function\") {\n    return value;\n  }\n  if (value.provider && typeof value.provider[feature] === \"function\") {\n    return value.provider;\n  }\n  return null;\n}\nfunction getProvider(value) {\n  if (value == null) {\n    return null;\n  }\n  return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nasync function copyOverrides(arg, allowed) {\n  // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n  const overrides = (0, provider_js_1.copyRequest)(index_js_1.Typed.dereference(arg, \"overrides\"));\n  (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n  (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n  // Resolve any from\n  if (overrides.from) {\n    overrides.from = await (0, index_js_2.resolveAddress)(overrides.from);\n  }\n  return overrides;\n}\nexports.copyOverrides = copyOverrides;\n/**\n *  @_ignore:\n */\nasync function resolveArgs(_runner, inputs, args) {\n  // Recursively descend into args and resolve any addresses\n  const runner = getRunner(_runner, \"resolveName\");\n  const resolver = canResolve(runner) ? runner : null;\n  return await Promise.all(inputs.map((param, index) => {\n    return param.walkAsync(args[index], (type, value) => {\n      value = index_js_1.Typed.dereference(value, type);\n      if (type === \"address\") {\n        return (0, index_js_2.resolveAddress)(value, resolver);\n      }\n      return value;\n    });\n  }));\n}\nexports.resolveArgs = resolveArgs;\nfunction buildWrappedFallback(contract) {\n  const populateTransaction = async function (overrides) {\n    // If an overrides was passed in, copy it and normalize the values\n    const tx = await copyOverrides(overrides, [\"data\"]);\n    tx.to = await contract.getAddress();\n    const iface = contract.interface;\n    const noValue = (0, index_js_3.getBigInt)(tx.value || BN_0, \"overrides.value\") === BN_0;\n    const noData = (tx.data || \"0x\") === \"0x\";\n    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n      (0, index_js_3.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n    }\n    (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n    // Only allow payable contracts to set non-zero value\n    const payable = iface.receive || iface.fallback && iface.fallback.payable;\n    (0, index_js_3.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n    // Only allow fallback contracts to set non-empty data\n    (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n    return tx;\n  };\n  const staticCall = async function (overrides) {\n    const runner = getRunner(contract.runner, \"call\");\n    (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"call\"\n    });\n    const tx = await populateTransaction(overrides);\n    try {\n      return await runner.call(tx);\n    } catch (error) {\n      if ((0, index_js_3.isCallException)(error) && error.data) {\n        throw contract.interface.makeError(error.data, tx);\n      }\n      throw error;\n    }\n  };\n  const send = async function (overrides) {\n    const runner = contract.runner;\n    (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const tx = await runner.sendTransaction(await populateTransaction(overrides));\n    const provider = getProvider(contract.runner);\n    // @TODO: the provider can be null; make a custom dummy provider that will throw a\n    // meaningful error\n    return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n  };\n  const estimateGas = async function (overrides) {\n    const runner = getRunner(contract.runner, \"estimateGas\");\n    (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"estimateGas\"\n    });\n    return await runner.estimateGas(await populateTransaction(overrides));\n  };\n  const method = async overrides => {\n    return await send(overrides);\n  };\n  (0, index_js_3.defineProperties)(method, {\n    _contract: contract,\n    estimateGas,\n    populateTransaction,\n    send,\n    staticCall\n  });\n  return method;\n}\nfunction buildWrappedMethod(contract, key) {\n  const getFragment = function (...args) {\n    const fragment = contract.interface.getFunction(key, args);\n    (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\"\n    });\n    return fragment;\n  };\n  const populateTransaction = async function (...args) {\n    const fragment = getFragment(...args);\n    // If an overrides was passed in, copy it and normalize the values\n    let overrides = {};\n    if (fragment.inputs.length + 1 === args.length) {\n      overrides = await copyOverrides(args.pop());\n    }\n    if (fragment.inputs.length !== args.length) {\n      throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n    }\n    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n    return Object.assign({}, overrides, await (0, index_js_3.resolveProperties)({\n      to: contract.getAddress(),\n      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n    }));\n  };\n  const staticCall = async function (...args) {\n    const result = await staticCallResult(...args);\n    if (result.length === 1) {\n      return result[0];\n    }\n    return result;\n  };\n  const send = async function (...args) {\n    const runner = contract.runner;\n    (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const tx = await runner.sendTransaction(await populateTransaction(...args));\n    const provider = getProvider(contract.runner);\n    // @TODO: the provider can be null; make a custom dummy provider that will throw a\n    // meaningful error\n    return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n  };\n  const estimateGas = async function (...args) {\n    const runner = getRunner(contract.runner, \"estimateGas\");\n    (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"estimateGas\"\n    });\n    return await runner.estimateGas(await populateTransaction(...args));\n  };\n  const staticCallResult = async function (...args) {\n    const runner = getRunner(contract.runner, \"call\");\n    (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"call\"\n    });\n    const tx = await populateTransaction(...args);\n    let result = \"0x\";\n    try {\n      result = await runner.call(tx);\n    } catch (error) {\n      if ((0, index_js_3.isCallException)(error) && error.data) {\n        throw contract.interface.makeError(error.data, tx);\n      }\n      throw error;\n    }\n    const fragment = getFragment(...args);\n    return contract.interface.decodeFunctionResult(fragment, result);\n  };\n  const method = async (...args) => {\n    const fragment = getFragment(...args);\n    if (fragment.constant) {\n      return await staticCall(...args);\n    }\n    return await send(...args);\n  };\n  (0, index_js_3.defineProperties)(method, {\n    name: contract.interface.getFunctionName(key),\n    _contract: contract,\n    _key: key,\n    getFragment,\n    estimateGas,\n    populateTransaction,\n    send,\n    staticCall,\n    staticCallResult\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: () => {\n      const fragment = contract.interface.getFunction(key);\n      (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\"\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\nfunction buildWrappedEvent(contract, key) {\n  const getFragment = function (...args) {\n    const fragment = contract.interface.getEvent(key, args);\n    (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\"\n    });\n    return fragment;\n  };\n  const method = function (...args) {\n    return new PreparedTopicFilter(contract, getFragment(...args), args);\n  };\n  (0, index_js_3.defineProperties)(method, {\n    name: contract.interface.getEventName(key),\n    _contract: contract,\n    _key: key,\n    getFragment\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: () => {\n      const fragment = contract.interface.getEvent(key);\n      (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\"\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n  internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n  return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n  return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n  let topics;\n  let fragment = null;\n  // Convert named events to topicHash and get the fragment for\n  // events which need deconstructing.\n  if (Array.isArray(event)) {\n    const topicHashify = function (name) {\n      if ((0, index_js_3.isHexString)(name, 32)) {\n        return name;\n      }\n      const fragment = contract.interface.getEvent(name);\n      (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n      return fragment.topicHash;\n    };\n    // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n    topics = event.map(e => {\n      if (e == null) {\n        return null;\n      }\n      if (Array.isArray(e)) {\n        return e.map(topicHashify);\n      }\n      return topicHashify(e);\n    });\n  } else if (event === \"*\") {\n    topics = [null];\n  } else if (typeof event === \"string\") {\n    if ((0, index_js_3.isHexString)(event, 32)) {\n      // Topic Hash\n      topics = [event];\n    } else {\n      // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n      fragment = contract.interface.getEvent(event);\n      (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n      topics = [fragment.topicHash];\n    }\n  } else if (isDeferred(event)) {\n    // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n    topics = await event.getTopicFilter();\n  } else if (\"fragment\" in event) {\n    // ContractEvent; e.g. `contract.filter.Transfer`\n    fragment = event.fragment;\n    topics = [fragment.topicHash];\n  } else {\n    (0, index_js_3.assertArgument)(false, \"unknown event name\", \"event\", event);\n  }\n  // Normalize topics and sort TopicSets\n  topics = topics.map(t => {\n    if (t == null) {\n      return null;\n    }\n    if (Array.isArray(t)) {\n      const items = Array.from(new Set(t.map(t => t.toLowerCase())).values());\n      if (items.length === 1) {\n        return items[0];\n      }\n      items.sort();\n      return items;\n    }\n    return t.toLowerCase();\n  });\n  const tag = topics.map(t => {\n    if (t == null) {\n      return \"null\";\n    }\n    if (Array.isArray(t)) {\n      return t.join(\"|\");\n    }\n    return t;\n  }).join(\"&\");\n  return {\n    fragment,\n    tag,\n    topics\n  };\n}\nasync function hasSub(contract, event) {\n  const {\n    subs\n  } = getInternal(contract);\n  return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n  // Make sure our runner can actually subscribe to events\n  const provider = getProvider(contract.runner);\n  (0, index_js_3.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n    operation\n  });\n  const {\n    fragment,\n    tag,\n    topics\n  } = await getSubInfo(contract, event);\n  const {\n    addr,\n    subs\n  } = getInternal(contract);\n  let sub = subs.get(tag);\n  if (!sub) {\n    const address = addr ? addr : contract;\n    const filter = {\n      address,\n      topics\n    };\n    const listener = log => {\n      let foundFragment = fragment;\n      if (foundFragment == null) {\n        try {\n          foundFragment = contract.interface.getEvent(log.topics[0]);\n        } catch (error) {}\n      }\n      // If fragment is null, we do not deconstruct the args to emit\n      if (foundFragment) {\n        const _foundFragment = foundFragment;\n        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n        emit(contract, event, args, listener => {\n          return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);\n        });\n      } else {\n        emit(contract, event, [], listener => {\n          return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);\n        });\n      }\n    };\n    let starting = [];\n    const start = () => {\n      if (starting.length) {\n        return;\n      }\n      starting.push(provider.on(filter, listener));\n    };\n    const stop = async () => {\n      if (starting.length == 0) {\n        return;\n      }\n      let started = starting;\n      starting = [];\n      await Promise.all(started);\n      provider.off(filter, listener);\n    };\n    sub = {\n      tag,\n      listeners: [],\n      start,\n      stop\n    };\n    subs.set(tag, sub);\n  }\n  return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n  await lastEmit;\n  const sub = await hasSub(contract, event);\n  if (!sub) {\n    return false;\n  }\n  const count = sub.listeners.length;\n  sub.listeners = sub.listeners.filter(({\n    listener,\n    once\n  }) => {\n    const passArgs = Array.from(args);\n    if (payloadFunc) {\n      passArgs.push(payloadFunc(once ? null : listener));\n    }\n    try {\n      listener.call(contract, ...passArgs);\n    } catch (error) {}\n    return !once;\n  });\n  return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n  try {\n    await lastEmit;\n  } catch (error) {}\n  const resultPromise = _emit(contract, event, args, payloadFunc);\n  lastEmit = resultPromise;\n  return await resultPromise;\n}\nconst passProperties = [\"then\"];\nclass BaseContract {\n  /**\n   *  The target to connect to.\n   *\n   *  This can be an address, ENS name or any [[Addressable]], such as\n   *  another contract. To get the resovled address, use the ``getAddress``\n   *  method.\n   */\n\n  /**\n   *  The contract Interface.\n   */\n\n  /**\n   *  The connected runner. This is generally a [[Provider]] or a\n   *  [[Signer]], which dictates what operations are supported.\n   *\n   *  For example, a **Contract** connected to a [[Provider]] may\n   *  only execute read-only operations.\n   */\n\n  /**\n   *  All the Events available on this contract.\n   */\n\n  /**\n   *  @_ignore:\n   */\n\n  /**\n   *  The fallback or receive function if any.\n   */\n\n  /**\n   *  Creates a new contract connected to %%target%% with the %%abi%% and\n   *  optionally connected to a %%runner%% to perform operations on behalf\n   *  of.\n   */\n  constructor(target, abi, runner, _deployTx) {\n    _defineProperty(this, \"target\", void 0);\n    _defineProperty(this, \"interface\", void 0);\n    _defineProperty(this, \"runner\", void 0);\n    _defineProperty(this, \"filters\", void 0);\n    _defineProperty(this, internal, void 0);\n    _defineProperty(this, \"fallback\", void 0);\n    (0, index_js_3.assertArgument)(typeof target === \"string\" || (0, index_js_2.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n    if (runner == null) {\n      runner = null;\n    }\n    const iface = index_js_1.Interface.from(abi);\n    (0, index_js_3.defineProperties)(this, {\n      target,\n      runner,\n      interface: iface\n    });\n    Object.defineProperty(this, internal, {\n      value: {}\n    });\n    let addrPromise;\n    let addr = null;\n    let deployTx = null;\n    if (_deployTx) {\n      const provider = getProvider(runner);\n      // @TODO: the provider can be null; make a custom dummy provider that will throw a\n      // meaningful error\n      deployTx = new wrappers_js_1.ContractTransactionResponse(this.interface, provider, _deployTx);\n    }\n    let subs = new Map();\n    // Resolve the target as the address\n    if (typeof target === \"string\") {\n      if ((0, index_js_3.isHexString)(target)) {\n        addr = target;\n        addrPromise = Promise.resolve(target);\n      } else {\n        const resolver = getRunner(runner, \"resolveName\");\n        if (!canResolve(resolver)) {\n          throw (0, index_js_3.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n          });\n        }\n        addrPromise = resolver.resolveName(target).then(addr => {\n          if (addr == null) {\n            throw new Error(\"TODO\");\n          }\n          getInternal(this).addr = addr;\n          return addr;\n        });\n      }\n    } else {\n      addrPromise = target.getAddress().then(addr => {\n        if (addr == null) {\n          throw new Error(\"TODO\");\n        }\n        getInternal(this).addr = addr;\n        return addr;\n      });\n    }\n    // Set our private values\n    setInternal(this, {\n      addrPromise,\n      addr,\n      deployTx,\n      subs\n    });\n    // Add the event filters\n    const filters = new Proxy({}, {\n      get: (target, _prop, receiver) => {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(_prop) >= 0) {\n          return Reflect.get(target, _prop, receiver);\n        }\n        const prop = String(_prop);\n        const result = this.getEvent(prop);\n        if (result) {\n          return result;\n        }\n        throw new Error(`unknown contract event: ${prop}`);\n      },\n      has: (target, prop) => {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n      }\n    });\n    (0, index_js_3.defineProperties)(this, {\n      filters\n    });\n    (0, index_js_3.defineProperties)(this, {\n      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n    });\n    // Return a Proxy that will respond to functions\n    return new Proxy(this, {\n      get: (target, _prop, receiver) => {\n        if (_prop in target || passProperties.indexOf(_prop) >= 0) {\n          return Reflect.get(target, _prop, receiver);\n        }\n        const prop = String(_prop);\n        const result = target.getFunction(prop);\n        if (result) {\n          return result;\n        }\n        throw new Error(`unknown contract method: ${prop}`);\n      },\n      has: (target, prop) => {\n        if (prop in target || passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return target.interface.hasFunction(String(prop));\n      }\n    });\n  }\n  /**\n   *  Return a new Contract instance with the same target and ABI, but\n   *  a different %%runner%%.\n   */\n  connect(runner) {\n    return new BaseContract(this.target, this.interface, runner);\n  }\n  /**\n   *  Return a new Contract instance with the same ABI and runner, but\n   *  a different %%target%%.\n   */\n  attach(target) {\n    return new BaseContract(target, this.interface, this.runner);\n  }\n  /**\n   *  Return the resolved address of this Contract.\n   */\n  async getAddress() {\n    return await getInternal(this).addrPromise;\n  }\n  /**\n   *  Return the dedployed bytecode or null if no bytecode is found.\n   */\n  async getDeployedCode() {\n    const provider = getProvider(this.runner);\n    (0, index_js_3.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"getDeployedCode\"\n    });\n    const code = await provider.getCode(await this.getAddress());\n    if (code === \"0x\") {\n      return null;\n    }\n    return code;\n  }\n  /**\n   *  Resolve to this Contract once the bytecode has been deployed, or\n   *  resolve immediately if already deployed.\n   */\n  async waitForDeployment() {\n    // We have the deployement transaction; just use that (throws if deployement fails)\n    const deployTx = this.deploymentTransaction();\n    if (deployTx) {\n      await deployTx.wait();\n      return this;\n    }\n    // Check for code\n    const code = await this.getDeployedCode();\n    if (code != null) {\n      return this;\n    }\n    // Make sure we can subscribe to a provider event\n    const provider = getProvider(this.runner);\n    (0, index_js_3.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"waitForDeployment\"\n    });\n    return new Promise((resolve, reject) => {\n      const checkCode = async () => {\n        try {\n          const code = await this.getDeployedCode();\n          if (code != null) {\n            return resolve(this);\n          }\n          provider.once(\"block\", checkCode);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      checkCode();\n    });\n  }\n  /**\n   *  Return the transaction used to deploy this contract.\n   *\n   *  This is only available if this instance was returned from a\n   *  [[ContractFactory]].\n   */\n  deploymentTransaction() {\n    return getInternal(this).deployTx;\n  }\n  /**\n   *  Return the function for a given name. This is useful when a contract\n   *  method name conflicts with a JavaScript name such as ``prototype`` or\n   *  when using a Contract programatically.\n   */\n  getFunction(key) {\n    if (typeof key !== \"string\") {\n      key = key.format();\n    }\n    const func = buildWrappedMethod(this, key);\n    return func;\n  }\n  /**\n   *  Return the event for a given name. This is useful when a contract\n   *  event name conflicts with a JavaScript name such as ``prototype`` or\n   *  when using a Contract programatically.\n   */\n  getEvent(key) {\n    if (typeof key !== \"string\") {\n      key = key.format();\n    }\n    return buildWrappedEvent(this, key);\n  }\n  /**\n   *  @_ignore:\n   */\n  async queryTransaction(hash) {\n    // Is this useful?\n    throw new Error(\"@TODO\");\n  }\n  /**\n   *  Provide historic access to event data for %%event%% in the range\n   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n   *  inclusive.\n   */\n  async queryFilter(event, fromBlock, toBlock) {\n    if (fromBlock == null) {\n      fromBlock = 0;\n    }\n    if (toBlock == null) {\n      toBlock = \"latest\";\n    }\n    const {\n      addr,\n      addrPromise\n    } = getInternal(this);\n    const address = addr ? addr : await addrPromise;\n    const {\n      fragment,\n      topics\n    } = await getSubInfo(this, event);\n    const filter = {\n      address,\n      topics,\n      fromBlock,\n      toBlock\n    };\n    const provider = getProvider(this.runner);\n    (0, index_js_3.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"queryFilter\"\n    });\n    return (await provider.getLogs(filter)).map(log => {\n      let foundFragment = fragment;\n      if (foundFragment == null) {\n        try {\n          foundFragment = this.interface.getEvent(log.topics[0]);\n        } catch (error) {}\n      }\n      if (foundFragment) {\n        return new wrappers_js_1.EventLog(log, this.interface, foundFragment);\n      } else {\n        return new provider_js_1.Log(log, provider);\n      }\n    });\n  }\n  /**\n   *  Add an event %%listener%% for the %%event%%.\n   */\n  async on(event, listener) {\n    const sub = await getSub(this, \"on\", event);\n    sub.listeners.push({\n      listener,\n      once: false\n    });\n    sub.start();\n    return this;\n  }\n  /**\n   *  Add an event %%listener%% for the %%event%%, but remove the listener\n   *  after it is fired once.\n   */\n  async once(event, listener) {\n    const sub = await getSub(this, \"once\", event);\n    sub.listeners.push({\n      listener,\n      once: true\n    });\n    sub.start();\n    return this;\n  }\n  /**\n   *  Emit an %%event%% calling all listeners with %%args%%.\n   *\n   *  Resolves to ``true`` if any listeners were called.\n   */\n  async emit(event, ...args) {\n    return await emit(this, event, args, null);\n  }\n  /**\n   *  Resolves to the number of listeners of %%event%% or the total number\n   *  of listeners if unspecified.\n   */\n  async listenerCount(event) {\n    if (event) {\n      const sub = await hasSub(this, event);\n      if (!sub) {\n        return 0;\n      }\n      return sub.listeners.length;\n    }\n    const {\n      subs\n    } = getInternal(this);\n    let total = 0;\n    for (const {\n      listeners\n    } of subs.values()) {\n      total += listeners.length;\n    }\n    return total;\n  }\n  /**\n   *  Resolves to the listeners subscribed to %%event%% or all listeners\n   *  if unspecified.\n   */\n  async listeners(event) {\n    if (event) {\n      const sub = await hasSub(this, event);\n      if (!sub) {\n        return [];\n      }\n      return sub.listeners.map(({\n        listener\n      }) => listener);\n    }\n    const {\n      subs\n    } = getInternal(this);\n    let result = [];\n    for (const {\n      listeners\n    } of subs.values()) {\n      result = result.concat(listeners.map(({\n        listener\n      }) => listener));\n    }\n    return result;\n  }\n  /**\n   *  Remove the %%listener%% from the listeners for %%event%% or remove\n   *  all listeners if unspecified.\n   */\n  async off(event, listener) {\n    const sub = await hasSub(this, event);\n    if (!sub) {\n      return this;\n    }\n    if (listener) {\n      const index = sub.listeners.map(({\n        listener\n      }) => listener).indexOf(listener);\n      if (index >= 0) {\n        sub.listeners.splice(index, 1);\n      }\n    }\n    if (listener == null || sub.listeners.length === 0) {\n      sub.stop();\n      getInternal(this).subs.delete(sub.tag);\n    }\n    return this;\n  }\n  /**\n   *  Remove all the listeners for %%event%% or remove all listeners if\n   *  unspecified.\n   */\n  async removeAllListeners(event) {\n    if (event) {\n      const sub = await hasSub(this, event);\n      if (!sub) {\n        return this;\n      }\n      sub.stop();\n      getInternal(this).subs.delete(sub.tag);\n    } else {\n      const {\n        subs\n      } = getInternal(this);\n      for (const {\n        tag,\n        stop\n      } of subs.values()) {\n        stop();\n        subs.delete(tag);\n      }\n    }\n    return this;\n  }\n  /**\n   *  Alias for [on].\n   */\n  async addListener(event, listener) {\n    return await this.on(event, listener);\n  }\n  /**\n   *  Alias for [off].\n   */\n  async removeListener(event, listener) {\n    return await this.off(event, listener);\n  }\n  /**\n   *  Create a new Class for the %%abi%%.\n   */\n  static buildClass(abi) {\n    class CustomContract extends BaseContract {\n      constructor(address, runner = null) {\n        super(address, abi, runner);\n      }\n    }\n    return CustomContract;\n  }\n  /**\n   *  Create a new BaseContract with a specified Interface.\n   */\n  static from(target, abi, runner) {\n    if (runner == null) {\n      runner = null;\n    }\n    const contract = new this(target, abi, runner);\n    return contract;\n  }\n}\nexports.BaseContract = BaseContract;\nfunction _ContractBase() {\n  return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nclass Contract extends _ContractBase() {}\nexports.Contract = Contract;","map":{"version":3,"sources":["../../src.ts/contract/contract.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;\nconst index_js_1 = require(\"../abi/index.js\");\nconst index_js_2 = require(\"../address/index.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = require(\"../providers/provider.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst wrappers_js_1 = require(\"./wrappers.js\");\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return (value && typeof (value.call) === \"function\");\n}\nfunction canEstimate(value) {\n    return (value && typeof (value.estimateGas) === \"function\");\n}\nfunction canResolve(value) {\n    return (value && typeof (value.resolveName) === \"function\");\n}\nfunction canSend(value) {\n    return (value && typeof (value.sendTransaction) === \"function\");\n}\nclass PreparedTopicFilter {\n    #filter;\n    fragment;\n    constructor(contract, fragment, args) {\n        (0, index_js_3.defineProperties)(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = (async function () {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        return (0, index_js_2.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value[feature]) === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof (value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nasync function copyOverrides(arg, allowed) {\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0, provider_js_1.copyRequest)(index_js_1.Typed.dereference(arg, \"overrides\"));\n    (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = await (0, index_js_2.resolveAddress)(overrides.from);\n    }\n    return overrides;\n}\nexports.copyOverrides = copyOverrides;\n/**\n *  @_ignore:\n */\nasync function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = index_js_1.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0, index_js_2.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nexports.resolveArgs = resolveArgs;\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function (overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = (await copyOverrides(overrides, [\"data\"]));\n        tx.to = await contract.getAddress();\n        const iface = contract.interface;\n        const noValue = ((0, index_js_3.getBigInt)((tx.value || BN_0), \"overrides.value\") === BN_0);\n        const noData = ((tx.data || \"0x\") === \"0x\");\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0, index_js_3.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        (0, index_js_3.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function (overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        }\n        catch (error) {\n            if ((0, index_js_3.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function (overrides) {\n        const runner = contract.runner;\n        (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides) => {\n        return await send(overrides);\n    };\n    (0, index_js_3.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n        return fragment;\n    };\n    const populateTransaction = async function (...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0, index_js_3.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function (...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function (...args) {\n        const runner = contract.runner;\n        (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function (...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        }\n        catch (error) {\n            if ((0, index_js_3.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0, index_js_3.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n        return fragment;\n    };\n    const method = function (...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0, index_js_3.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n            (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return (value && typeof (value) === \"object\" && (\"getTopicFilter\" in value) &&\n        (typeof (value.getTopicFilter) === \"function\") && value.fragment);\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function (name) {\n            if ((0, index_js_3.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    }\n    else if (event === \"*\") {\n        topics = [null];\n    }\n    else if (typeof (event) === \"string\") {\n        if ((0, index_js_3.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [event];\n        }\n        else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [fragment.topicHash];\n        }\n    }\n    else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    }\n    else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [fragment.topicHash];\n    }\n    else {\n        (0, index_js_3.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t) => {\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return { fragment, tag, topics };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0, index_js_3.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", { operation });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = (addr ? addr : contract);\n        const filter = { address, topics };\n        const listener = (log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener) => {\n                    return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            }\n            else {\n                emit(contract, event, [], (listener) => {\n                    return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = () => {\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async () => {\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = { tag, listeners: [], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        }\n        catch (error) { }\n        return !once;\n    });\n    return (count > 0);\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    }\n    catch (error) { }\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\"then\"];\nclass BaseContract {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    target;\n    /**\n     *  The contract Interface.\n     */\n    interface;\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    runner;\n    /**\n     *  All the Events available on this contract.\n     */\n    filters;\n    /**\n     *  @_ignore:\n     */\n    [internal];\n    /**\n     *  The fallback or receive function if any.\n     */\n    fallback;\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */\n    constructor(target, abi, runner, _deployTx) {\n        (0, index_js_3.assertArgument)(typeof (target) === \"string\" || (0, index_js_2.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = index_js_1.Interface.from(abi);\n        (0, index_js_3.defineProperties)(this, { target, runner, interface: iface });\n        Object.defineProperty(this, internal, { value: {} });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new wrappers_js_1.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof (target) === \"string\") {\n            if ((0, index_js_3.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            }\n            else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0, index_js_3.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) {\n                        throw new Error(\"TODO\");\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        }\n        else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, _prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n                const prop = String(_prop);\n                const result = this.getEvent(prop);\n                if (result) {\n                    return result;\n                }\n                throw new Error(`unknown contract event: ${prop}`);\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0, index_js_3.defineProperties)(this, { filters });\n        (0, index_js_3.defineProperties)(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, _prop, receiver) => {\n                if (_prop in target || passProperties.indexOf(_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n                const prop = String(_prop);\n                const result = target.getFunction(prop);\n                if (result) {\n                    return result;\n                }\n                throw new Error(`unknown contract method: ${prop}`);\n            },\n            has: (target, prop) => {\n                if (prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(String(prop));\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */\n    connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n    attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */\n    async getAddress() { return await getInternal(this).addrPromise; }\n    /**\n     *  Return the dedployed bytecode or null if no bytecode is found.\n     */\n    async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0, index_js_3.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n    async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0, index_js_3.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                }\n                catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n    deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getFunction(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getEvent(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */\n    async queryTransaction(hash) {\n        // Is this useful?\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n    async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr : (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n        const provider = getProvider(this.runner);\n        (0, index_js_3.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            if (foundFragment) {\n                return new wrappers_js_1.EventLog(log, this.interface, foundFragment);\n            }\n            else {\n                return new provider_js_1.Log(log, provider);\n            }\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n    async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n    async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n    async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n    async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n    async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n    async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n    async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */\n    async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n    static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    ;\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nexports.BaseContract = BaseContract;\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nclass Contract extends _ContractBase() {\n}\nexports.Contract = Contract;\n//# sourceMappingURL=contract.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}