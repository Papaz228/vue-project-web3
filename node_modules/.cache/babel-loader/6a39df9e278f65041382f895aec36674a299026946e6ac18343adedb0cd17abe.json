{"ast":null,"code":"\"use strict\";\n\n/**\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptCrowdsaleJson = exports.isCrowdsaleJson = void 0;\nconst aes_js_1 = require(\"aes-js\");\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\nconst index_js_3 = require(\"../hash/index.js\");\nconst index_js_4 = require(\"../utils/index.js\");\nconst utils_js_1 = require(\"./utils.js\");\n/**\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\n */\nfunction isCrowdsaleJson(json) {\n  try {\n    const data = JSON.parse(json);\n    if (data.encseed) {\n      return true;\n    }\n  } catch (error) {}\n  return false;\n}\nexports.isCrowdsaleJson = isCrowdsaleJson;\n// See: https://github.com/ethereum/pyethsaletool\n/**\n *  Before Ethereum launched, it was necessary to create a wallet\n *  format for backers to use, which would be used to receive ether\n *  as a reward for contributing to the project.\n *\n *  The [[link-crowdsale]] format is now obsolete, but it is still\n *  useful to support and the additional code is fairly trivial as\n *  all the primitives required are used through core portions of\n *  the library.\n */\nfunction decryptCrowdsaleJson(json, _password) {\n  const data = JSON.parse(json);\n  const password = (0, utils_js_1.getPassword)(_password);\n  // Ethereum Address\n  const address = (0, index_js_1.getAddress)((0, utils_js_1.spelunk)(data, \"ethaddr:string!\"));\n  // Encrypted Seed\n  const encseed = (0, utils_js_1.looseArrayify)((0, utils_js_1.spelunk)(data, \"encseed:string!\"));\n  (0, index_js_4.assertArgument)(encseed && encseed.length % 16 === 0, \"invalid encseed\", \"json\", json);\n  const key = (0, index_js_4.getBytes)((0, index_js_2.pbkdf2)(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n  const iv = encseed.slice(0, 16);\n  const encryptedSeed = encseed.slice(16);\n  // Decrypt the seed\n  const aesCbc = new aes_js_1.CBC(key, iv);\n  const seed = (0, aes_js_1.pkcs7Strip)((0, index_js_4.getBytes)(aesCbc.decrypt(encryptedSeed)));\n  // This wallet format is weird... Convert the binary encoded hex to a string.\n  let seedHex = \"\";\n  for (let i = 0; i < seed.length; i++) {\n    seedHex += String.fromCharCode(seed[i]);\n  }\n  return {\n    address,\n    privateKey: (0, index_js_3.id)(seedHex)\n  };\n}\nexports.decryptCrowdsaleJson = decryptCrowdsaleJson;","map":{"version":3,"sources":["../../src.ts/wallet/json-crowdsale.ts"],"names":[],"mappings":";;AAAA;;AAEG;;;;;AAEH,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAEA,MAAA,UAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAEA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAYA;;AAEG;AACH,SAAgB,eAAe,CAAC,IAAY,EAAA;EACxC,IAAI;IACA,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;IAC7B,IAAI,IAAI,CAAC,OAAO,EAAE;MAAE,OAAO,IAAI;IAAG;GACrC,CAAC,OAAO,KAAK,EAAE,CAAA;EAChB,OAAO,KAAK;AAChB;AANA,OAAA,CAAA,eAAA,GAAA,eAAA;AAQA;AAEA;;;;;;;;;AASG;AACH,SAAgB,oBAAoB,CAAC,IAAY,EAAE,SAA8B,EAAA;EAC7E,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;EAC7B,MAAM,QAAQ,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,WAAW,EAAC,SAAS,CAAC;EAEvC;EACA,MAAM,OAAO,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,UAAU,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,OAAO,EAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;EAE5D;EACA,MAAM,OAAO,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,aAAa,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,OAAO,EAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;EAC/D,CAAA,CAAA,EAAA,UAAA,CAAA,cAAc,EAAC,OAAO,IAAK,OAAO,CAAC,MAAM,GAAG,EAAE,KAAM,CAAC,EAAE,iBAAiB,EAAE,MAAM,EAAE,IAAI,CAAC;EAEvF,MAAM,GAAG,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,QAAQ,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,MAAM,EAAC,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EAEjF,MAAM,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EAC/B,MAAM,aAAa,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;EAEvC;EACA,MAAM,MAAM,GAAG,IAAI,QAAA,CAAA,GAAG,CAAC,GAAG,EAAE,EAAE,CAAC;EAC/B,MAAM,IAAI,GAAG,CAAA,CAAA,EAAA,QAAA,CAAA,UAAU,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,QAAQ,EAAC,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC;EAEhE;EACA,IAAI,OAAO,GAAG,EAAE;EAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IAClC,OAAO,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;EAC1C;EAED,OAAO;IAAE,OAAO;IAAE,UAAU,EAAE,CAAA,CAAA,EAAA,UAAA,CAAA,EAAE,EAAC,OAAO;EAAC,CAAE;AAC/C;AA3BA,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptCrowdsaleJson = exports.isCrowdsaleJson = void 0;\nconst aes_js_1 = require(\"aes-js\");\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\nconst index_js_3 = require(\"../hash/index.js\");\nconst index_js_4 = require(\"../utils/index.js\");\nconst utils_js_1 = require(\"./utils.js\");\n/**\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\n */\nfunction isCrowdsaleJson(json) {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) {\n            return true;\n        }\n    }\n    catch (error) { }\n    return false;\n}\nexports.isCrowdsaleJson = isCrowdsaleJson;\n// See: https://github.com/ethereum/pyethsaletool\n/**\n *  Before Ethereum launched, it was necessary to create a wallet\n *  format for backers to use, which would be used to receive ether\n *  as a reward for contributing to the project.\n *\n *  The [[link-crowdsale]] format is now obsolete, but it is still\n *  useful to support and the additional code is fairly trivial as\n *  all the primitives required are used through core portions of\n *  the library.\n */\nfunction decryptCrowdsaleJson(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0, utils_js_1.getPassword)(_password);\n    // Ethereum Address\n    const address = (0, index_js_1.getAddress)((0, utils_js_1.spelunk)(data, \"ethaddr:string!\"));\n    // Encrypted Seed\n    const encseed = (0, utils_js_1.looseArrayify)((0, utils_js_1.spelunk)(data, \"encseed:string!\"));\n    (0, index_js_4.assertArgument)(encseed && (encseed.length % 16) === 0, \"invalid encseed\", \"json\", json);\n    const key = (0, index_js_4.getBytes)((0, index_js_2.pbkdf2)(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n    // Decrypt the seed\n    const aesCbc = new aes_js_1.CBC(key, iv);\n    const seed = (0, aes_js_1.pkcs7Strip)((0, index_js_4.getBytes)(aesCbc.decrypt(encryptedSeed)));\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n    return { address, privateKey: (0, index_js_3.id)(seedHex) };\n}\nexports.decryptCrowdsaleJson = decryptCrowdsaleJson;\n//# sourceMappingURL=json-crowdsale.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}