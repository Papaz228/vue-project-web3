{"ast":null,"code":"\"use strict\";\n\n/**\n *  The JSON Wallet formats allow a simple way to store the private\n *  keys needed in Ethereum along with related information and allows\n *  for extensible forms of encryption.\n *\n *  These utilities facilitate decrypting and encrypting the most common\n *  JSON Wallet formats.\n *\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encryptKeystoreJson = exports.encryptKeystoreJsonSync = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = void 0;\nconst aes_js_1 = require(\"aes-js\");\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\nconst index_js_3 = require(\"../transaction/index.js\");\nconst index_js_4 = require(\"../utils/index.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst _version_js_1 = require(\"../_version.js\");\nconst defaultPath = \"m/44'/60'/0'/0/0\";\n/**\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\n */\nfunction isKeystoreJson(json) {\n  try {\n    const data = JSON.parse(json);\n    const version = data.version != null ? parseInt(data.version) : 0;\n    if (version === 3) {\n      return true;\n    }\n  } catch (error) {}\n  return false;\n}\nexports.isKeystoreJson = isKeystoreJson;\nfunction decrypt(data, key, ciphertext) {\n  const cipher = (0, utils_js_1.spelunk)(data, \"crypto.cipher:string\");\n  if (cipher === \"aes-128-ctr\") {\n    const iv = (0, utils_js_1.spelunk)(data, \"crypto.cipherparams.iv:data!\");\n    const aesCtr = new aes_js_1.CTR(key, iv);\n    return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));\n  }\n  (0, index_js_4.assert)(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"decrypt\"\n  });\n}\nfunction getAccount(data, _key) {\n  const key = (0, index_js_4.getBytes)(_key);\n  const ciphertext = (0, utils_js_1.spelunk)(data, \"crypto.ciphertext:data!\");\n  const computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([key.slice(16, 32), ciphertext]))).substring(2);\n  (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, \"crypto.mac:string!\").toLowerCase(), \"incorrect password\", \"password\", \"[ REDACTED ]\");\n  const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\n  const address = (0, index_js_3.computeAddress)(privateKey);\n  if (data.address) {\n    let check = data.address.toLowerCase();\n    if (!check.startsWith(\"0x\")) {\n      check = \"0x\" + check;\n    }\n    (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\n  }\n  const account = {\n    address,\n    privateKey\n  };\n  // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n  const version = (0, utils_js_1.spelunk)(data, \"x-ethers.version:string\");\n  if (version === \"0.1\") {\n    const mnemonicKey = key.slice(32, 64);\n    const mnemonicCiphertext = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCiphertext:data!\");\n    const mnemonicIv = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCounter:data!\");\n    const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n    account.mnemonic = {\n      path: (0, utils_js_1.spelunk)(data, \"x-ethers.path:string\") || defaultPath,\n      locale: (0, utils_js_1.spelunk)(data, \"x-ethers.locale:string\") || \"en\",\n      entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\n    };\n  }\n  return account;\n}\nfunction getDecryptKdfParams(data) {\n  const kdf = (0, utils_js_1.spelunk)(data, \"crypto.kdf:string\");\n  if (kdf && typeof kdf === \"string\") {\n    if (kdf.toLowerCase() === \"scrypt\") {\n      const salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n      const N = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.n:int!\");\n      const r = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.r:int!\");\n      const p = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.p:int!\");\n      // Make sure N is a power of 2\n      (0, index_js_4.assertArgument)(N > 0 && (N & N - 1) === 0, \"invalid kdf.N\", \"kdf.N\", N);\n      (0, index_js_4.assertArgument)(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\n      const dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n      (0, index_js_4.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\n      return {\n        name: \"scrypt\",\n        salt,\n        N,\n        r,\n        p,\n        dkLen: 64\n      };\n    } else if (kdf.toLowerCase() === \"pbkdf2\") {\n      const salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n      const prf = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.prf:string!\");\n      const algorithm = prf.split(\"-\").pop();\n      (0, index_js_4.assertArgument)(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\n      const count = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.c:int!\");\n      const dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n      (0, index_js_4.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", dkLen);\n      return {\n        name: \"pbkdf2\",\n        salt,\n        count,\n        dkLen,\n        algorithm\n      };\n    }\n  }\n  (0, index_js_4.assertArgument)(false, \"unsupported key-derivation function\", \"kdf\", kdf);\n}\n/**\n *  Returns the account details for the JSON Keystore Wallet %%json%%\n *  using %%password%%.\n *\n *  It is preferred to use the [async version](decryptKeystoreJson)\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\n *  as to the decryption status.\n *\n *  This method will block the event loop (freezing all UI) until decryption\n *  is complete, which can take quite some time, depending on the wallet\n *  paramters and platform.\n */\nfunction decryptKeystoreJsonSync(json, _password) {\n  const data = JSON.parse(json);\n  const password = (0, utils_js_1.getPassword)(_password);\n  const params = getDecryptKdfParams(data);\n  if (params.name === \"pbkdf2\") {\n    const {\n      salt,\n      count,\n      dkLen,\n      algorithm\n    } = params;\n    const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);\n    return getAccount(data, key);\n  }\n  (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\n    params\n  });\n  const {\n    salt,\n    N,\n    r,\n    p,\n    dkLen\n  } = params;\n  const key = (0, index_js_2.scryptSync)(password, salt, N, r, p, dkLen);\n  return getAccount(data, key);\n}\nexports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, duration);\n  });\n}\n/**\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n *  %%password%%.\n *\n *  If provided, %%progress%% will be called periodically during the\n *  decrpytion to provide feedback, and if the function returns\n *  ``false`` will halt decryption.\n *\n *  The %%progressCallback%% will **always** receive ``0`` before\n *  decryption begins and ``1`` when complete.\n */\nasync function decryptKeystoreJson(json, _password, progress) {\n  const data = JSON.parse(json);\n  const password = (0, utils_js_1.getPassword)(_password);\n  const params = getDecryptKdfParams(data);\n  if (params.name === \"pbkdf2\") {\n    if (progress) {\n      progress(0);\n      await stall(0);\n    }\n    const {\n      salt,\n      count,\n      dkLen,\n      algorithm\n    } = params;\n    const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);\n    if (progress) {\n      progress(1);\n      await stall(0);\n    }\n    return getAccount(data, key);\n  }\n  (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\n    params\n  });\n  const {\n    salt,\n    N,\n    r,\n    p,\n    dkLen\n  } = params;\n  const key = await (0, index_js_2.scrypt)(password, salt, N, r, p, dkLen, progress);\n  return getAccount(data, key);\n}\nexports.decryptKeystoreJson = decryptKeystoreJson;\nfunction getEncryptKdfParams(options) {\n  // Check/generate the salt\n  const salt = options.salt != null ? (0, index_js_4.getBytes)(options.salt, \"options.salt\") : (0, index_js_2.randomBytes)(32);\n  // Override the scrypt password-based key derivation function parameters\n  let N = 1 << 17,\n    r = 8,\n    p = 1;\n  if (options.scrypt) {\n    if (options.scrypt.N) {\n      N = options.scrypt.N;\n    }\n    if (options.scrypt.r) {\n      r = options.scrypt.r;\n    }\n    if (options.scrypt.p) {\n      p = options.scrypt.p;\n    }\n  }\n  (0, index_js_4.assertArgument)(typeof N === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\n  (0, index_js_4.assertArgument)(typeof r === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\n  (0, index_js_4.assertArgument)(typeof p === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\n  return {\n    name: \"scrypt\",\n    dkLen: 32,\n    salt,\n    N,\n    r,\n    p\n  };\n}\nfunction _encryptKeystore(key, kdf, account, options) {\n  const privateKey = (0, index_js_4.getBytes)(account.privateKey, \"privateKey\");\n  // Override initialization vector\n  const iv = options.iv != null ? (0, index_js_4.getBytes)(options.iv, \"options.iv\") : (0, index_js_2.randomBytes)(16);\n  (0, index_js_4.assertArgument)(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\n  // Override the uuid\n  const uuidRandom = options.uuid != null ? (0, index_js_4.getBytes)(options.uuid, \"options.uuid\") : (0, index_js_2.randomBytes)(16);\n  (0, index_js_4.assertArgument)(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\n  // This will be used to encrypt the wallet (as per Web3 secret storage)\n  // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n  // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n  const derivedKey = key.slice(0, 16);\n  const macPrefix = key.slice(16, 32);\n  // Encrypt the private key\n  const aesCtr = new aes_js_1.CTR(derivedKey, iv);\n  const ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));\n  // Compute the message authentication code, used to check the password\n  const mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([macPrefix, ciphertext]));\n  // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n  const data = {\n    address: account.address.substring(2).toLowerCase(),\n    id: (0, index_js_4.uuidV4)(uuidRandom),\n    version: 3,\n    Crypto: {\n      cipher: \"aes-128-ctr\",\n      cipherparams: {\n        iv: (0, index_js_4.hexlify)(iv).substring(2)\n      },\n      ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),\n      kdf: \"scrypt\",\n      kdfparams: {\n        salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),\n        n: kdf.N,\n        dklen: 32,\n        p: kdf.p,\n        r: kdf.r\n      },\n      mac: mac.substring(2)\n    }\n  };\n  // If we have a mnemonic, encrypt it into the JSON wallet\n  if (account.mnemonic) {\n    const client = options.client != null ? options.client : `ethers/${_version_js_1.version}`;\n    const path = account.mnemonic.path || defaultPath;\n    const locale = account.mnemonic.locale || \"en\";\n    const mnemonicKey = key.slice(32, 64);\n    const entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, \"account.mnemonic.entropy\");\n    const mnemonicIv = (0, index_js_2.randomBytes)(16);\n    const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n    const mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));\n    const now = new Date();\n    const timestamp = now.getUTCFullYear() + \"-\" + (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + \"-\" + (0, utils_js_1.zpad)(now.getUTCDate(), 2) + \"T\" + (0, utils_js_1.zpad)(now.getUTCHours(), 2) + \"-\" + (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + \"-\" + (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + \".0Z\";\n    const gethFilename = \"UTC--\" + timestamp + \"--\" + data.address;\n    data[\"x-ethers\"] = {\n      client,\n      gethFilename,\n      path,\n      locale,\n      mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),\n      mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),\n      version: \"0.1\"\n    };\n  }\n  return JSON.stringify(data);\n}\n/**\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\n *  %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used. Any provided [[ProgressCallback]] is ignord.\n */\nfunction encryptKeystoreJsonSync(account, password, options) {\n  if (options == null) {\n    options = {};\n  }\n  const passwordBytes = (0, utils_js_1.getPassword)(password);\n  const kdf = getEncryptKdfParams(options);\n  const key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\n  return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);\n}\nexports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;\n/**\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\n *  with %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used and provide a [[ProgressCallback]] to receive periodic updates\n *  on the completion status..\n */\nasync function encryptKeystoreJson(account, password, options) {\n  if (options == null) {\n    options = {};\n  }\n  const passwordBytes = (0, utils_js_1.getPassword)(password);\n  const kdf = getEncryptKdfParams(options);\n  const key = await (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\n  return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);\n}\nexports.encryptKeystoreJson = encryptKeystoreJson;","map":{"version":3,"sources":["../../src.ts/wallet/json-keystore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n *  The JSON Wallet formats allow a simple way to store the private\n *  keys needed in Ethereum along with related information and allows\n *  for extensible forms of encryption.\n *\n *  These utilities facilitate decrypting and encrypting the most common\n *  JSON Wallet formats.\n *\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encryptKeystoreJson = exports.encryptKeystoreJsonSync = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = void 0;\nconst aes_js_1 = require(\"aes-js\");\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\nconst index_js_3 = require(\"../transaction/index.js\");\nconst index_js_4 = require(\"../utils/index.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst _version_js_1 = require(\"../_version.js\");\nconst defaultPath = \"m/44'/60'/0'/0/0\";\n/**\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\n */\nfunction isKeystoreJson(json) {\n    try {\n        const data = JSON.parse(json);\n        const version = ((data.version != null) ? parseInt(data.version) : 0);\n        if (version === 3) {\n            return true;\n        }\n    }\n    catch (error) { }\n    return false;\n}\nexports.isKeystoreJson = isKeystoreJson;\nfunction decrypt(data, key, ciphertext) {\n    const cipher = (0, utils_js_1.spelunk)(data, \"crypto.cipher:string\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = (0, utils_js_1.spelunk)(data, \"crypto.cipherparams.iv:data!\");\n        const aesCtr = new aes_js_1.CTR(key, iv);\n        return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));\n    }\n    (0, index_js_4.assert)(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"decrypt\"\n    });\n}\nfunction getAccount(data, _key) {\n    const key = (0, index_js_4.getBytes)(_key);\n    const ciphertext = (0, utils_js_1.spelunk)(data, \"crypto.ciphertext:data!\");\n    const computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([key.slice(16, 32), ciphertext]))).substring(2);\n    (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, \"crypto.mac:string!\").toLowerCase(), \"incorrect password\", \"password\", \"[ REDACTED ]\");\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\n    const address = (0, index_js_3.computeAddress)(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (!check.startsWith(\"0x\")) {\n            check = \"0x\" + check;\n        }\n        (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\n    }\n    const account = { address, privateKey };\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    const version = (0, utils_js_1.spelunk)(data, \"x-ethers.version:string\");\n    if (version === \"0.1\") {\n        const mnemonicKey = key.slice(32, 64);\n        const mnemonicCiphertext = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCiphertext:data!\");\n        const mnemonicIv = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCounter:data!\");\n        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n        account.mnemonic = {\n            path: ((0, utils_js_1.spelunk)(data, \"x-ethers.path:string\") || defaultPath),\n            locale: ((0, utils_js_1.spelunk)(data, \"x-ethers.locale:string\") || \"en\"),\n            entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\n        };\n    }\n    return account;\n}\nfunction getDecryptKdfParams(data) {\n    const kdf = (0, utils_js_1.spelunk)(data, \"crypto.kdf:string\");\n    if (kdf && typeof (kdf) === \"string\") {\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const N = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.n:int!\");\n            const r = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.r:int!\");\n            const p = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.p:int!\");\n            // Make sure N is a power of 2\n            (0, index_js_4.assertArgument)(N > 0 && (N & (N - 1)) === 0, \"invalid kdf.N\", \"kdf.N\", N);\n            (0, index_js_4.assertArgument)(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\n            const dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0, index_js_4.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\n            return { name: \"scrypt\", salt, N, r, p, dkLen: 64 };\n        }\n        else if (kdf.toLowerCase() === \"pbkdf2\") {\n            const salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const prf = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.prf:string!\");\n            const algorithm = prf.split(\"-\").pop();\n            (0, index_js_4.assertArgument)(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\n            const count = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.c:int!\");\n            const dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0, index_js_4.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", dkLen);\n            return { name: \"pbkdf2\", salt, count, dkLen, algorithm };\n        }\n    }\n    (0, index_js_4.assertArgument)(false, \"unsupported key-derivation function\", \"kdf\", kdf);\n}\n/**\n *  Returns the account details for the JSON Keystore Wallet %%json%%\n *  using %%password%%.\n *\n *  It is preferred to use the [async version](decryptKeystoreJson)\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\n *  as to the decryption status.\n *\n *  This method will block the event loop (freezing all UI) until decryption\n *  is complete, which can take quite some time, depending on the wallet\n *  paramters and platform.\n */\nfunction decryptKeystoreJsonSync(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0, utils_js_1.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);\n        return getAccount(data, key);\n    }\n    (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params });\n    const { salt, N, r, p, dkLen } = params;\n    const key = (0, index_js_2.scryptSync)(password, salt, N, r, p, dkLen);\n    return getAccount(data, key);\n}\nexports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;\nfunction stall(duration) {\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\n}\n/**\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n *  %%password%%.\n *\n *  If provided, %%progress%% will be called periodically during the\n *  decrpytion to provide feedback, and if the function returns\n *  ``false`` will halt decryption.\n *\n *  The %%progressCallback%% will **always** receive ``0`` before\n *  decryption begins and ``1`` when complete.\n */\nasync function decryptKeystoreJson(json, _password, progress) {\n    const data = JSON.parse(json);\n    const password = (0, utils_js_1.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        if (progress) {\n            progress(0);\n            await stall(0);\n        }\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);\n        if (progress) {\n            progress(1);\n            await stall(0);\n        }\n        return getAccount(data, key);\n    }\n    (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params });\n    const { salt, N, r, p, dkLen } = params;\n    const key = await (0, index_js_2.scrypt)(password, salt, N, r, p, dkLen, progress);\n    return getAccount(data, key);\n}\nexports.decryptKeystoreJson = decryptKeystoreJson;\nfunction getEncryptKdfParams(options) {\n    // Check/generate the salt\n    const salt = (options.salt != null) ? (0, index_js_4.getBytes)(options.salt, \"options.salt\") : (0, index_js_2.randomBytes)(32);\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) {\n            N = options.scrypt.N;\n        }\n        if (options.scrypt.r) {\n            r = options.scrypt.r;\n        }\n        if (options.scrypt.p) {\n            p = options.scrypt.p;\n        }\n    }\n    (0, index_js_4.assertArgument)(typeof (N) === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\n    (0, index_js_4.assertArgument)(typeof (r) === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\n    (0, index_js_4.assertArgument)(typeof (p) === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\n    return { name: \"scrypt\", dkLen: 32, salt, N, r, p };\n}\nfunction _encryptKeystore(key, kdf, account, options) {\n    const privateKey = (0, index_js_4.getBytes)(account.privateKey, \"privateKey\");\n    // Override initialization vector\n    const iv = (options.iv != null) ? (0, index_js_4.getBytes)(options.iv, \"options.iv\") : (0, index_js_2.randomBytes)(16);\n    (0, index_js_4.assertArgument)(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\n    // Override the uuid\n    const uuidRandom = (options.uuid != null) ? (0, index_js_4.getBytes)(options.uuid, \"options.uuid\") : (0, index_js_2.randomBytes)(16);\n    (0, index_js_4.assertArgument)(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\n    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32);\n    // Encrypt the private key\n    const aesCtr = new aes_js_1.CTR(derivedKey, iv);\n    const ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));\n    // Compute the message authentication code, used to check the password\n    const mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([macPrefix, ciphertext]));\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n    const data = {\n        address: account.address.substring(2).toLowerCase(),\n        id: (0, index_js_4.uuidV4)(uuidRandom),\n        version: 3,\n        Crypto: {\n            cipher: \"aes-128-ctr\",\n            cipherparams: {\n                iv: (0, index_js_4.hexlify)(iv).substring(2),\n            },\n            ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),\n            kdf: \"scrypt\",\n            kdfparams: {\n                salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),\n                n: kdf.N,\n                dklen: 32,\n                p: kdf.p,\n                r: kdf.r\n            },\n            mac: mac.substring(2)\n        }\n    };\n    // If we have a mnemonic, encrypt it into the JSON wallet\n    if (account.mnemonic) {\n        const client = (options.client != null) ? options.client : `ethers/${_version_js_1.version}`;\n        const path = account.mnemonic.path || defaultPath;\n        const locale = account.mnemonic.locale || \"en\";\n        const mnemonicKey = key.slice(32, 64);\n        const entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, \"account.mnemonic.entropy\");\n        const mnemonicIv = (0, index_js_2.randomBytes)(16);\n        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n        const mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));\n        const now = new Date();\n        const timestamp = (now.getUTCFullYear() + \"-\" +\n            (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + \"-\" +\n            (0, utils_js_1.zpad)(now.getUTCDate(), 2) + \"T\" +\n            (0, utils_js_1.zpad)(now.getUTCHours(), 2) + \"-\" +\n            (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + \"-\" +\n            (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + \".0Z\");\n        const gethFilename = (\"UTC--\" + timestamp + \"--\" + data.address);\n        data[\"x-ethers\"] = {\n            client, gethFilename, path, locale,\n            mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),\n            mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),\n            version: \"0.1\"\n        };\n    }\n    return JSON.stringify(data);\n}\n/**\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\n *  %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used. Any provided [[ProgressCallback]] is ignord.\n */\nfunction encryptKeystoreJsonSync(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0, utils_js_1.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\n    return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);\n}\nexports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;\n/**\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\n *  with %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used and provide a [[ProgressCallback]] to receive periodic updates\n *  on the completion status..\n */\nasync function encryptKeystoreJson(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0, utils_js_1.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = await (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\n    return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);\n}\nexports.encryptKeystoreJson = encryptKeystoreJson;\n//# sourceMappingURL=json-keystore.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}