{"ast":null,"code":"\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeRlp = void 0;\nconst data_js_1 = require(\"./data.js\");\nconst errors_js_1 = require(\"./errors.js\");\nconst data_js_2 = require(\"./data.js\");\nfunction hexlifyByte(value) {\n  let result = value.toString(16);\n  while (result.length < 2) {\n    result = \"0\" + result;\n  }\n  return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n  let result = 0;\n  for (let i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n  return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n  const result = [];\n  while (childOffset < offset + 1 + length) {\n    const decoded = _decode(data, childOffset);\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n    (0, errors_js_1.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length,\n      offset\n    });\n  }\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n  (0, errors_js_1.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n    buffer: data,\n    length: 0,\n    offset: 1\n  });\n  const checkOffset = offset => {\n    (0, errors_js_1.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n      buffer: data,\n      length: data.length,\n      offset\n    });\n  };\n  // Array with extra length prefix\n  if (data[offset] >= 0xf8) {\n    const lengthLength = data[offset] - 0xf7;\n    checkOffset(offset + 1 + lengthLength);\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    checkOffset(offset + 1 + lengthLength + length);\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    const length = data[offset] - 0xc0;\n    checkOffset(offset + 1 + length);\n    return _decodeChildren(data, offset, offset + 1, length);\n  } else if (data[offset] >= 0xb8) {\n    const lengthLength = data[offset] - 0xb7;\n    checkOffset(offset + 1 + lengthLength);\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    checkOffset(offset + 1 + lengthLength + length);\n    const result = (0, data_js_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n    return {\n      consumed: 1 + lengthLength + length,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    const length = data[offset] - 0x80;\n    checkOffset(offset + 1 + length);\n    const result = (0, data_js_1.hexlify)(data.slice(offset + 1, offset + 1 + length));\n    return {\n      consumed: 1 + length,\n      result: result\n    };\n  }\n  return {\n    consumed: 1,\n    result: hexlifyByte(data[offset])\n  };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nfunction decodeRlp(_data) {\n  const data = (0, data_js_2.getBytes)(_data, \"data\");\n  const decoded = _decode(data, 0);\n  (0, errors_js_1.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n  return decoded.result;\n}\nexports.decodeRlp = decodeRlp;","map":{"version":3,"sources":["../../src.ts/utils/rlp-decode.ts"],"names":[],"mappings":";;AAAA;AAAA,OAAA;;;;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AAKA,SAAS,WAAW,CAAC,KAAa,EAAA;EAC9B,IAAI,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC;EAC/B,OAAO,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;IAAE,MAAM,GAAG,GAAG,GAAG,MAAM;EAAG;EACpD,OAAO,IAAI,GAAG,MAAM;AACxB;AAEA,SAAS,iBAAiB,CAAC,IAAgB,EAAE,MAAc,EAAE,MAAc,EAAA;EACvE,IAAI,MAAM,GAAG,CAAC;EACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;IAC7B,MAAM,GAAI,MAAM,GAAG,GAAG,GAAI,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;EAC7C;EACD,OAAO,MAAM;AACjB;AAOA,SAAS,eAAe,CAAC,IAAgB,EAAE,MAAc,EAAE,WAAmB,EAAE,MAAc,EAAA;EAC1F,MAAM,MAAM,GAAG,EAAE;EAEjB,OAAO,WAAW,GAAG,MAAM,GAAG,CAAC,GAAG,MAAM,EAAE;IACtC,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,EAAE,WAAW,CAAC;IAE1C,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;IAE3B,WAAW,IAAI,OAAO,CAAC,QAAQ;IAC/B,CAAA,CAAA,EAAA,WAAA,CAAA,MAAM,EAAC,WAAW,IAAI,MAAM,GAAG,CAAC,GAAG,MAAM,EAAE,sBAAsB,EAAE,gBAAgB,EAAE;MACjF,MAAM,EAAE,IAAI;MAAE,MAAM;MAAE;KACzB,CAAC;EACL;EAED,OAAO;IAAC,QAAQ,EAAG,CAAC,GAAG,MAAO;IAAE,MAAM,EAAE;EAAM,CAAC;AACnD;AAEA;AACA,SAAS,OAAO,CAAC,IAAgB,EAAE,MAAc,EAAA;EAC7C,CAAA,CAAA,EAAA,WAAA,CAAA,MAAM,EAAC,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,gBAAgB,EAAE,gBAAgB,EAAE;IAC1D,MAAM,EAAE,IAAI;IAAE,MAAM,EAAE,CAAC;IAAE,MAAM,EAAE;GACpC,CAAC;EAEF,MAAM,WAAW,GAAI,MAAc,IAAI;IACnC,CAAA,CAAA,EAAA,WAAA,CAAA,MAAM,EAAC,MAAM,IAAI,IAAI,CAAC,MAAM,EAAE,8BAA8B,EAAE,gBAAgB,EAAE;MAC5E,MAAM,EAAE,IAAI;MAAE,MAAM,EAAE,IAAI,CAAC,MAAM;MAAE;KACtC,CAAC;EACN,CAAC;EAED;EACA,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,EAAE;IACtB,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI;IACxC,WAAW,CAAC,MAAM,GAAG,CAAC,GAAG,YAAY,CAAC;IAEtC,MAAM,MAAM,GAAG,iBAAiB,CAAC,IAAI,EAAE,MAAM,GAAG,CAAC,EAAE,YAAY,CAAC;IAChE,WAAW,CAAC,MAAM,GAAG,CAAC,GAAG,YAAY,GAAG,MAAM,CAAC;IAE/C,OAAO,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,GAAG,CAAC,GAAG,YAAY,EAAE,YAAY,GAAG,MAAM,CAAC;GAEzF,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,EAAE;IAC7B,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI;IAClC,WAAW,CAAC,MAAM,GAAG,CAAC,GAAG,MAAM,CAAC;IAEhC,OAAO,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,GAAG,CAAC,EAAE,MAAM,CAAC;GAE3D,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,EAAE;IAC7B,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI;IACxC,WAAW,CAAC,MAAM,GAAG,CAAC,GAAG,YAAY,CAAC;IAEtC,MAAM,MAAM,GAAG,iBAAiB,CAAC,IAAI,EAAE,MAAM,GAAG,CAAC,EAAE,YAAY,CAAC;IAChE,WAAW,CAAC,MAAM,GAAG,CAAC,GAAG,YAAY,GAAG,MAAM,CAAC;IAE/C,MAAM,MAAM,GAAG,CAAA,CAAA,EAAA,SAAA,CAAA,OAAO,EAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,GAAG,YAAY,EAAE,MAAM,GAAG,CAAC,GAAG,YAAY,GAAG,MAAM,CAAC,CAAC;IACjG,OAAO;MAAE,QAAQ,EAAG,CAAC,GAAG,YAAY,GAAG,MAAO;MAAE,MAAM,EAAE;IAAM,CAAE;GAEnE,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,EAAE;IAC7B,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI;IAClC,WAAW,CAAC,MAAM,GAAG,CAAC,GAAG,MAAM,CAAC;IAEhC,MAAM,MAAM,GAAG,CAAA,CAAA,EAAA,SAAA,CAAA,OAAO,EAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,GAAG,MAAM,CAAC,CAAC;IACnE,OAAO;MAAE,QAAQ,EAAG,CAAC,GAAG,MAAO;MAAE,MAAM,EAAE;IAAM,CAAE;EACpD;EAED,OAAO;IAAE,QAAQ,EAAE,CAAC;IAAE,MAAM,EAAE,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC;EAAC,CAAE;AAC7D;AAEA;;AAEG;AACH,SAAgB,SAAS,CAAC,KAAgB,EAAA;EACtC,MAAM,IAAI,GAAG,CAAA,CAAA,EAAA,SAAA,CAAA,QAAQ,EAAC,KAAK,EAAE,MAAM,CAAC;EACpC,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;EAChC,CAAA,CAAA,EAAA,WAAA,CAAA,cAAc,EAAC,OAAO,CAAC,QAAQ,KAAK,IAAI,CAAC,MAAM,EAAE,mCAAmC,EAAE,MAAM,EAAE,KAAK,CAAC;EACpG,OAAO,OAAO,CAAC,MAAM;AACzB;AALA,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n//See: https://github.com/ethereum/wiki/wiki/RLP\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeRlp = void 0;\nconst data_js_1 = require(\"./data.js\");\nconst errors_js_1 = require(\"./errors.js\");\nconst data_js_2 = require(\"./data.js\");\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while (result.length < 2) {\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0, errors_js_1.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length, offset\n        });\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0, errors_js_1.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data, length: 0, offset: 1\n    });\n    const checkOffset = (offset) => {\n        (0, errors_js_1.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data, length: data.length, offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0, data_js_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0, data_js_1.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */\nfunction decodeRlp(_data) {\n    const data = (0, data_js_2.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0, errors_js_1.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}\nexports.decodeRlp = decodeRlp;\n//# sourceMappingURL=rlp-decode.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}