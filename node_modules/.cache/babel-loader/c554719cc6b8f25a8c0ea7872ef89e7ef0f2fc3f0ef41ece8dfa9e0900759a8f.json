{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyMessage = exports.hashMessage = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../constants/index.js\");\nconst index_js_3 = require(\"../transaction/index.js\");\nconst index_js_4 = require(\"../utils/index.js\");\n/**\n *  Computes the [[link-eip-191]] personal-sign message digest to sign.\n *\n *  This prefixes the message with [[MessagePrefix]] and the decimal length\n *  of %%message%% and computes the [[keccak256]] digest.\n *\n *  If %%message%% is a string, it is converted to its UTF-8 bytes\n *  first. To compute the digest of a [[DataHexString]], it must be converted\n *  to [bytes](getBytes).\n *\n *  @example:\n *    hashMessage(\"Hello World\")\n *    //_result:\n *\n *    // Hashes the SIX (6) string characters, i.e.\n *    // [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\n *    hashMessage(\"0x4243\")\n *    //_result:\n *\n *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\n *    hashMessage(getBytes(\"0x4243\"))\n *    //_result:\n *\n *    // ...which is equal to using data\n *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))\n *    //_result:\n *\n */\nfunction hashMessage(message) {\n  if (typeof message === \"string\") {\n    message = (0, index_js_4.toUtf8Bytes)(message);\n  }\n  return (0, index_js_1.keccak256)((0, index_js_4.concat)([(0, index_js_4.toUtf8Bytes)(index_js_2.MessagePrefix), (0, index_js_4.toUtf8Bytes)(String(message.length)), message]));\n}\nexports.hashMessage = hashMessage;\n/**\n *  Return the address of the private key that produced\n *  the signature %%sig%% during signing for %%message%%.\n */\nfunction verifyMessage(message, sig) {\n  const digest = hashMessage(message);\n  return (0, index_js_3.recoverAddress)(digest, sig);\n}\nexports.verifyMessage = verifyMessage;","map":{"version":3,"sources":["../../src.ts/hash/message.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BG;AACH,SAAgB,WAAW,CAAC,OAA4B,EAAA;EACpD,IAAI,OAAO,OAAQ,KAAK,QAAQ,EAAE;IAAE,OAAO,GAAG,CAAA,CAAA,EAAA,UAAA,CAAA,WAAW,EAAC,OAAO,CAAC;EAAG;EACrE,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,SAAS,EAAC,CAAA,CAAA,EAAA,UAAA,CAAA,MAAM,EAAC,CACpB,CAAA,CAAA,EAAA,UAAA,CAAA,WAAW,EAAC,UAAA,CAAA,aAAa,CAAC,EAC1B,CAAA,CAAA,EAAA,UAAA,CAAA,WAAW,EAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,EACnC,OAAO,CACV,CAAC,CAAC;AACP;AAPA,OAAA,CAAA,WAAA,GAAA,WAAA;AASA;;;AAGG;AACH,SAAgB,aAAa,CAAC,OAA4B,EAAE,GAAkB,EAAA;EAC1E,MAAM,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;EACnC,OAAO,CAAA,CAAA,EAAA,UAAA,CAAA,cAAc,EAAC,MAAM,EAAE,GAAG,CAAC;AACtC;AAHA,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifyMessage = exports.hashMessage = void 0;\nconst index_js_1 = require(\"../crypto/index.js\");\nconst index_js_2 = require(\"../constants/index.js\");\nconst index_js_3 = require(\"../transaction/index.js\");\nconst index_js_4 = require(\"../utils/index.js\");\n/**\n *  Computes the [[link-eip-191]] personal-sign message digest to sign.\n *\n *  This prefixes the message with [[MessagePrefix]] and the decimal length\n *  of %%message%% and computes the [[keccak256]] digest.\n *\n *  If %%message%% is a string, it is converted to its UTF-8 bytes\n *  first. To compute the digest of a [[DataHexString]], it must be converted\n *  to [bytes](getBytes).\n *\n *  @example:\n *    hashMessage(\"Hello World\")\n *    //_result:\n *\n *    // Hashes the SIX (6) string characters, i.e.\n *    // [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\n *    hashMessage(\"0x4243\")\n *    //_result:\n *\n *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\n *    hashMessage(getBytes(\"0x4243\"))\n *    //_result:\n *\n *    // ...which is equal to using data\n *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))\n *    //_result:\n *\n */\nfunction hashMessage(message) {\n    if (typeof (message) === \"string\") {\n        message = (0, index_js_4.toUtf8Bytes)(message);\n    }\n    return (0, index_js_1.keccak256)((0, index_js_4.concat)([\n        (0, index_js_4.toUtf8Bytes)(index_js_2.MessagePrefix),\n        (0, index_js_4.toUtf8Bytes)(String(message.length)),\n        message\n    ]));\n}\nexports.hashMessage = hashMessage;\n/**\n *  Return the address of the private key that produced\n *  the signature %%sig%% during signing for %%message%%.\n */\nfunction verifyMessage(message, sig) {\n    const digest = hashMessage(message);\n    return (0, index_js_3.recoverAddress)(digest, sig);\n}\nexports.verifyMessage = verifyMessage;\n//# sourceMappingURL=message.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}