{"ast":null,"code":"\"use strict\";\n\nvar _classPrivateFieldInitSpec = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _defineProperty = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateFieldGet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"/home/alan/VisualStudioProjects/BU/vue-proj1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseWallet = void 0;\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../hash/index.js\");\nconst index_js_3 = require(\"../providers/index.js\");\nconst index_js_4 = require(\"../transaction/index.js\");\nconst index_js_5 = require(\"../utils/index.js\");\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nvar _signingKey = /*#__PURE__*/new WeakMap();\nclass BaseWallet extends index_js_3.AbstractSigner {\n  /**\n   *  The wallet address.\n   */\n\n  /**\n   *  Creates a new BaseWallet for %%privateKey%%, optionally\n   *  connected to %%provider%%.\n   *\n   *  If %%provider%% is not specified, only offline methods can\n   *  be used.\n   */\n  constructor(privateKey, provider) {\n    super(provider);\n    _defineProperty(this, \"address\", void 0);\n    _classPrivateFieldInitSpec(this, _signingKey, {\n      writable: true,\n      value: void 0\n    });\n    (0, index_js_5.assertArgument)(privateKey && typeof privateKey.sign === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n    _classPrivateFieldSet(this, _signingKey, privateKey);\n    const address = (0, index_js_4.computeAddress)(this.signingKey.publicKey);\n    (0, index_js_5.defineProperties)(this, {\n      address\n    });\n  }\n  // Store private values behind getters to reduce visibility\n  // in console.log\n  /**\n   *  The [[SigningKey]] used for signing payloads.\n   */\n  get signingKey() {\n    return _classPrivateFieldGet(this, _signingKey);\n  }\n  /**\n   *  The private key for this wallet.\n   */\n  get privateKey() {\n    return this.signingKey.privateKey;\n  }\n  async getAddress() {\n    return this.address;\n  }\n  connect(provider) {\n    return new BaseWallet(_classPrivateFieldGet(this, _signingKey), provider);\n  }\n  async signTransaction(tx) {\n    // Replace any Addressable or ENS name with an address\n    const {\n      to,\n      from\n    } = await (0, index_js_5.resolveProperties)({\n      to: tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : undefined,\n      from: tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : undefined\n    });\n    if (to != null) {\n      tx.to = to;\n    }\n    if (from != null) {\n      tx.from = from;\n    }\n    if (tx.from != null) {\n      (0, index_js_5.assertArgument)((0, index_js_1.getAddress)(tx.from) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n      delete tx.from;\n    }\n    // Build the transaction\n    const btx = index_js_4.Transaction.from(tx);\n    btx.signature = this.signingKey.sign(btx.unsignedHash);\n    return btx.serialized;\n  }\n  async signMessage(message) {\n    return this.signMessageSync(message);\n  }\n  // @TODO: Add a secialized signTx and signTyped sync that enforces\n  // all parameters are known?\n  /**\n   *  Returns the signature for %%message%% signed with this wallet.\n   */\n  signMessageSync(message) {\n    return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;\n  }\n  async signTypedData(domain, types, value) {\n    // Populate any ENS names\n    const populated = await index_js_2.TypedDataEncoder.resolveNames(domain, types, value, async name => {\n      // @TODO: this should use resolveName; addresses don't\n      //        need a provider\n      (0, index_js_5.assert)(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"resolveName\",\n        info: {\n          name\n        }\n      });\n      const address = await this.provider.resolveName(name);\n      (0, index_js_5.assert)(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n        value: name\n      });\n      return address;\n    });\n    return this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n  }\n}\nexports.BaseWallet = BaseWallet;","map":{"version":3,"sources":["../../src.ts/wallet/base-wallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseWallet = void 0;\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../hash/index.js\");\nconst index_js_3 = require(\"../providers/index.js\");\nconst index_js_4 = require(\"../transaction/index.js\");\nconst index_js_5 = require(\"../utils/index.js\");\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nclass BaseWallet extends index_js_3.AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    address;\n    #signingKey;\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%% is not specified, only offline methods can\n     *  be used.\n     */\n    constructor(privateKey, provider) {\n        super(provider);\n        (0, index_js_5.assertArgument)(privateKey && typeof (privateKey.sign) === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n        this.#signingKey = privateKey;\n        const address = (0, index_js_4.computeAddress)(this.signingKey.publicKey);\n        (0, index_js_5.defineProperties)(this, { address });\n    }\n    // Store private values behind getters to reduce visibility\n    // in console.log\n    /**\n     *  The [[SigningKey]] used for signing payloads.\n     */\n    get signingKey() { return this.#signingKey; }\n    /**\n     *  The private key for this wallet.\n     */\n    get privateKey() { return this.signingKey.privateKey; }\n    async getAddress() { return this.address; }\n    connect(provider) {\n        return new BaseWallet(this.#signingKey, provider);\n    }\n    async signTransaction(tx) {\n        // Replace any Addressable or ENS name with an address\n        const { to, from } = await (0, index_js_5.resolveProperties)({\n            to: (tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : undefined),\n            from: (tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : undefined)\n        });\n        if (to != null) {\n            tx.to = to;\n        }\n        if (from != null) {\n            tx.from = from;\n        }\n        if (tx.from != null) {\n            (0, index_js_5.assertArgument)((0, index_js_1.getAddress)((tx.from)) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n            delete tx.from;\n        }\n        // Build the transaction\n        const btx = index_js_4.Transaction.from(tx);\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\n        return btx.serialized;\n    }\n    async signMessage(message) {\n        return this.signMessageSync(message);\n    }\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */\n    signMessageSync(message) {\n        return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;\n    }\n    async signTypedData(domain, types, value) {\n        // Populate any ENS names\n        const populated = await index_js_2.TypedDataEncoder.resolveNames(domain, types, value, async (name) => {\n            // @TODO: this should use resolveName; addresses don't\n            //        need a provider\n            (0, index_js_5.assert)(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"resolveName\",\n                info: { name }\n            });\n            const address = await this.provider.resolveName(name);\n            (0, index_js_5.assert)(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                value: name\n            });\n            return address;\n        });\n        return this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n    }\n}\nexports.BaseWallet = BaseWallet;\n//# sourceMappingURL=base-wallet.js.map"]},"metadata":{},"sourceType":"script","externalDependencies":[]}